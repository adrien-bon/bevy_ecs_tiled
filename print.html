<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>bevy_ecs_tiled Documentation</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="FAQ.html">FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Design and explanation</li><li class="chapter-item expanded "><a href="design/why_tiled.html"><strong aria-hidden="true">1.</strong> Why using Tiled ?</a></li><li class="chapter-item expanded "><a href="design/entities_hierarchy.html"><strong aria-hidden="true">2.</strong> Entities hierarchy and marker components</a></li><li class="chapter-item expanded "><a href="design/z_order.html"><strong aria-hidden="true">3.</strong> Z-ordering</a></li><li class="chapter-item expanded "><a href="design/map_events.html"><strong aria-hidden="true">4.</strong> Map loading events</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Coordinates conversion between Tiled and Bevy</div></li><li class="chapter-item expanded affix "><li class="part-title">How-To's</li><li class="chapter-item expanded "><a href="guides/minimal.html"><strong aria-hidden="true">6.</strong> Minimal working example</a></li><li class="chapter-item expanded "><a href="guides/spawn_reload.html"><strong aria-hidden="true">7.</strong> Spawn / Despawn / Reload a map</a></li><li class="chapter-item expanded "><a href="guides/physics.html"><strong aria-hidden="true">8.</strong> Add physics colliders</a></li><li class="chapter-item expanded "><a href="guides/properties.html"><strong aria-hidden="true">9.</strong> Use Tiled custom properties</a></li><li class="chapter-item expanded "><a href="guides/debug.html"><strong aria-hidden="true">10.</strong> Debug your project</a></li><li class="chapter-item expanded affix "><li class="part-title">Migration guides</li><li class="chapter-item expanded "><a href="migrations/v0_6.html"><strong aria-hidden="true">11.</strong> From v0.5.X to v0.6.X</a></li><li class="chapter-item expanded "><a href="migrations/v0_5.html"><strong aria-hidden="true">12.</strong> From v0.4.X to v0.5.X</a></li><li class="chapter-item expanded "><a href="migrations/v0_4.html"><strong aria-hidden="true">13.</strong> From v0.3.X to v0.4.X</a></li><li class="chapter-item expanded affix "><li class="part-title">Miscellaneous</li><li class="chapter-item expanded "><a href="misc/useful-links.html"><strong aria-hidden="true">14.</strong> Useful links</a></li><li class="chapter-item expanded "><a href="misc/contributing.html"><strong aria-hidden="true">15.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="misc/api-reference.html"><strong aria-hidden="true">16.</strong> API reference</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">bevy_ecs_tiled Documentation</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/adrien-bon/bevy_ecs_tiled"><code>bevy_ecs_tiled</code></a> is a <a href="https://bevyengine.org/">Bevy</a> plugin for working with 2D tilemaps created with the <a href="https://www.mapeditor.org/">Tiled map editor</a>.</p>
<p>It relies upon the official <a href="https://github.com/mapeditor/rs-tiled">Tiled Rust bindings</a> to parse and load Tiled map files and the <a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code> crate</a> to perform rendering.</p>
<p>It aims to provide a simple and ergonomic workflow by using Tiled as an editor when working on Bevy 2D games.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>Support for several kind of maps: orthogonal, isometric or hexagonal maps, finite or infinite layers, with external or embedded tilesets, using atlases or several images.</li>
<li>Support various Tiled features: animated tiles, images layers, tile objects or <a href="https://doc.mapeditor.org/en/stable/manual/worlds/">Tiled world</a> when a single map is not enough.</li>
<li>Each Tiled item, such as layer, tile or object, is represented by a Bevy entity and everything is organized under a Bevy hierarchy: layers are children of the Tiled map entity, tiles and objects are children of these layers. <code>Visibility</code> and <code>Transform</code> are automatically propagated down the hierarchy.</li>
<li>Easily control how to spawn and despawn maps. Use Bevy events and observers to customize how your scene is spawned or notify you when the map is actually loaded and ready to use.</li>
<li>Build your map in Tiled and let the plugin take care of the rest:
<ul>
<li>Automatically spawn <a href="https://rapier.rs/">Rapier</a> or <a href="https://github.com/Jondolf/avian">Avian</a> physics colliders on tiles or objects.</li>
<li>Use <a href="https://doc.mapeditor.org/en/stable/manual/custom-properties/">Tiled custom properties</a> to automatically insert your own components on objects, tiles or layers.</li>
</ul>
</li>
<li>Hot-reloading: work on your map in Tiled and see it update in Bevy without having to re-compile / restart your game.</li>
</ul>
<hr />
<p><strong>Disclaimer:</strong> both this book and the whole crate have been heavilly inspired by the <a href="https://github.com/Trouv/bevy_ecs_ldtk"><code>bevy_ecs_ldtk</code> crate</a>, which is basically the equivalent of <code>bevy_ecs_tiled</code> but for the <a href="https://ldtk.io/">LDTK</a> map editor.
Thanks for the inspiration! :)</p>
<hr />
<h2 id="purpose-of-this-book"><a class="header" href="#purpose-of-this-book">Purpose of this book</a></h2>
<p>This book aims to give you a better understanding of how <a href="https://github.com/adrien-bon/bevy_ecs_tiled"><code>bevy_ecs_tiled</code></a> works, what you can achieve with it and how you can do it.</p>
<p>It will focus on high-level concepts, design concerns and basic tutorials.
If you need an API reference, please have a look at the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/"><code>bevy_ecs_tiled</code> API reference</a>.
The <a href="https://github.com/adrien-bon/bevy_ecs_tiled/tree/main/examples/README.md">examples</a> directory is also a good place to start.</p>
<p>Finally, this book assume you already have some sort of knowledge about <a href="https://bevyengine.org/">Bevy</a> and <a href="https://www.mapeditor.org/">Tiled</a> map editor.
There are already some good documentations available on these topics and some resources are referenced <a href="misc/useful-links.html">in the dedicated section</a>.</p>
<h2 id="architecture-of-this-book"><a class="header" href="#architecture-of-this-book">Architecture of this book</a></h2>
<p>This book is divided in several categories:</p>
<ul>
<li><strong>Design and explanation</strong>: how does the plugin work and why some technical choices have been made;</li>
<li><strong>How-To's</strong>: in-depth tutorials about a specific aspect of  the plugin;</li>
<li><strong>Migration guides</strong>: migration guides for specific versions;</li>
<li><strong>Miscellaneous</strong>: other topics that did not fit in other categories.</li>
</ul>
<p>Good reading ! :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="whats-the-current-status-of-the-crate-"><a class="header" href="#whats-the-current-status-of-the-crate-">What's the current status of the crate ?</a></h2>
<p>While the crate is already definitely usable, it is still under active development.</p>
<p>Expect bugs, missing features and breaking changes !</p>
<p>However, I plan to follow semver and to provide a migration guide each time there are breaking changes (for instance, upon a new Bevy release).</p>
<h2 id="what-kind-of-maps-are-supported-"><a class="header" href="#what-kind-of-maps-are-supported-">What kind of maps are supported ?</a></h2>
<p>We should support nearly all maps from Tiled :</p>
<ul>
<li>orthogonal</li>
<li>&quot;flat-top&quot; hexagonal</li>
<li>&quot;pointy-top&quot; hexagonal</li>
<li>&quot;diamond&quot; isometric</li>
</ul>
<p>There is however an exception: we do not (and don't plan to) support isometric &quot;staggered&quot; maps (<a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues/31">#31</a>).</p>
<p>Also, some of the feature are currently not working very well for &quot;diamond&quot; isometric maps: colliders don't have the proper shape (<a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues/32">#32</a>) and are not always at the right place (<a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues/48">#48</a>).
But we hope to have better support for them in the future.</p>
<h2 id="im-using-an-isometric-map-and-it-seems-all-messed-up-"><a class="header" href="#im-using-an-isometric-map-and-it-seems-all-messed-up-">I'm using an isometric map and it seems all messed up !</a></h2>
<p>Make sure you are actually using a &quot;diamond&quot; map and not a &quot;staggered&quot; one, which are not supported.</p>
<p>Also, for isometric maps, you may want to tweak the <a href="https://docs.rs/bevy_ecs_tilemap/latest/bevy_ecs_tilemap/map/struct.TilemapRenderSettings.html"><code>TilemapRenderSettings</code></a> component from <code>bevy_ecs_tilemap</code> to enable Y-sorting and adjust the chunk size.</p>
<p>More information in the <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/orientation_isometric.rs#L34">isometric maps example</a></p>
<h2 id="i-want-to-add-physics-to-my-game-how-should-i-do-"><a class="header" href="#i-want-to-add-physics-to-my-game-how-should-i-do-">I want to add physics to my game, how should I do ?</a></h2>
<p>You can automatically spawn physics colliders on tiles or objects using either <a href="https://github.com/Jondolf/avian">Avian</a> or <a href="https://github.com/dimforge/bevy_rapier">Rapier</a> physics backend.
Basically, all you have to do is to add another plugin to your app.
The crate handle the rest.</p>
<p>You can select on which objects or tiles you colliders are spawn based upon their name and using Tiled builtin collision editor.
Everything is explained in the <a href="guides/physics.html">dedicated guide</a>.</p>
<h2 id="i-want-to-update-my-bevy-entities-directly-from-tiled-how-should-i-do-"><a class="header" href="#i-want-to-update-my-bevy-entities-directly-from-tiled-how-should-i-do-">I want to update my Bevy entities directly from Tiled, how should I do ?</a></h2>
<p>Let's say you are building a top-down turn-based RPG.
You probably want to give each of your tile some kind of information to determine if it can be crossed and what's the associated movement cost.</p>
<p>Using <a href="https://doc.mapeditor.org/en/stable/manual/custom-properties/">Tiled custom properties</a>, we can define this information in Tiled editor: the crate will automatically insert the corresponding Bevy <code>Component</code> on the tile entity when you load the map, so you can use it in your game logic.
See the <a href="guides/properties.html">dedicated guide</a> for more information.</p>
<h2 id="how-to-enable-map-hot-reload-"><a class="header" href="#how-to-enable-map-hot-reload-">How to enable map hot-reload ?</a></h2>
<p>You need to enable Bevy <code>file_watcher</code> feature.
<code>bevy_ecs_tiled</code> will then be able to automatically reload a map that was updated with Tiled.</p>
<h2 id="i-found-a-bug---feature-x-is-missing---how-do-i-do-y-"><a class="header" href="#i-found-a-bug---feature-x-is-missing---how-do-i-do-y-">I found a bug ! / Feature 'X' is missing ! / How do I do 'Y' ?</a></h2>
<p>This crate is still a work in-progress so it's likely you'll find bugs, miss some feature or just wonder how to achieve something.</p>
<p>You can have a look to <a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues">already openned issues</a> and if it does not already exist, please fill a new one !
I try to address every issue as quickly as possible.</p>
<p>Also, contributions are more than welcome !
If you want to contribute, please have a look to <a href="misc/contributing.html">contribution guide</a> and feel free to open a PR ! :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-using-tiled-"><a class="header" href="#why-using-tiled-">Why using Tiled ?</a></h1>
<p><a href="https://www.mapeditor.org/">Tiled</a> may feel a bit outdated in terms of &quot;look and feel&quot;, especially when compared with more modern map editor tools like <a href="https://ldtk.io/">LDTK</a>.
However it has <strong>a lot</strong> of features which make it very interesting.</p>
<p>If we compare with <a href="https://ldtk.io/">LDTK</a>, they both have a set of powerful features like:</p>
<ul>
<li>auto-tiling</li>
<li>adding gameplay informations to map tiles and objects</li>
<li>working with worlds</li>
</ul>
<p>But <a href="https://www.mapeditor.org/">Tiled</a> also have a set of unique features:</p>
<ul>
<li>support for both isometric and hexagonal maps</li>
<li>native support for animated tiled</li>
</ul>
<p>Since I specifically wanted to work with hexagonal maps the choice was obvious for me !</p>
<p>However, if it's not your case and you just want to use orthogonal map, you could give a shot at using <a href="https://ldtk.io/">LDTK</a> instead, especially using the <a href="https://github.com/Trouv/bevy_ecs_ldtk"><code>bevy_ecs_ldtk</code> crate</a>.
Or stay with <a href="https://www.mapeditor.org/">Tiled</a>, it also works :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities-hierarchy-and-marker-components"><a class="header" href="#entities-hierarchy-and-marker-components">Entities hierarchy and marker components</a></h1>
<p>When a map is loaded, it spawns <strong>a lot</strong> of entities: for the map, for layers, for tiles, for objects, for colliders, ...
To keep things nice and tidy, these entites are organized in a <a href="https://bevy-cheatbook.github.io/fundamentals/hierarchy.html">parent / child hierarchy</a> and every entity has an associated marker component to help with queries.</p>
<p>Using a hierachy also brings the capability to inherit some of the component from top-level entities down the tree.
For instance, if you change the <code>Visibility</code> of a layer entity, it will automatically apply to all entities below in the hierarchy such as tiles or objects.</p>
<h2 id="hierarchy"><a class="header" href="#hierarchy">Hierarchy</a></h2>
<h3 id="world"><a class="header" href="#world">World</a></h3>
<p>When loading a <code>.world</code> asset, you will have a <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/world/struct.TiledWolrdMarker.html"><code>TiledWorldMarker</code></a> at the top of the tree.</p>
<p>This entity holds the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/world/struct.TiledWorldHandle.html"><code>TiledWorldHandle</code></a> pointing to your <code>.world</code> asset and all the settings that apply to it.</p>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p>When loading a single <code>.tmx</code> asset, you will have a single <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapMarker.html"><code>TiledMapMarker</code></a> at the top of the tree.
Otherwise, if working with a Tiled world, you will have several maps which are children of the top-level world.</p>
<p>This entity holds the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/struct.TiledMapHandle.html"><code>TiledMapHandle</code></a> component pointing to your <code>.tmx</code> file and all the settings that apply to it.</p>
<h3 id="layers"><a class="header" href="#layers">Layers</a></h3>
<p>Below the map, we have the layers.
They can be of different kinds, which each have their own marker component:</p>
<ul>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/map/components/struct.TiledMapObjectLayer.html"><code>TiledMapObjectLayer</code></a>: for objects layer.</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/map/components/struct.TiledMapTileLayer.html"><code>TiledMapTileLayer</code></a>: for tiles layer.</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/map/components/struct.TiledMapImageLayer.html"><code>TiledMapImageLayer</code></a>: for image layer.</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/map/components/struct.TiledMapGroupLayer.html"><code>TiledMapGroupLayer</code></a>: for group layer (not supported for now).</li>
</ul>
<p>All of them are also identified by the same generic marker: <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/map/components/struct.TiledMapLayer.html"><code>TiledMapLayer</code></a>.</p>
<h3 id="objects"><a class="header" href="#objects">Objects</a></h3>
<p>Objects are directly below their <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/map/struct.TiledMapObjectLayer.html"><code>TiledMapObjectLayer</code></a>.
They are identified by a <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/map/struct.TiledMapObject.html"><code>TiledMapObject</code></a> marker.</p>
<h3 id="tiles"><a class="header" href="#tiles">Tiles</a></h3>
<p>For tiles, it's a little more complicated.</p>
<p>Below the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/map/struct.TiledMapTileLayer.html"><code>TiledMapTileLayer</code></a>, we first have one <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/map/components/struct.TiledMapTileLayerForTileset.html"><code>TiledMapTileLayerForTileset</code></a> per tileset in the map.
And below these, we find the actual <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/map/components/struct.TiledMapTile.html"><code>TiledMapTile</code></a> which correspond to a tile in the layer, for a given tileset.</p>
<h3 id="physics-colliders"><a class="header" href="#physics-colliders">Physics colliders</a></h3>
<p>At the bottom of the hierarchy, we find physics colliders.
They are spawned below they &quot;source&quot;, ie. either a tile layer or an object and they can be identified using their marker component: <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/physics/collider/struct.TiledColliderMarker.html"><code>TiledColliderMarker</code></a>.</p>
<h2 id="transform-and-visibility-propagation"><a class="header" href="#transform-and-visibility-propagation">Transform and Visibility propagation</a></h2>
<p>You can refer to the Bevy cheatbook to get an overview of how <a href="https://bevy-cheatbook.github.io/fundamentals/transforms.html"><code>Transform</code></a> and <a href="https://bevy-cheatbook.github.io/fundamentals/visibility.html"><code>Visibility</code></a> propagation works in general.</p>
<p>In two words, it means that if you change one of these components for a top-level entity, for instance a layer, it will propagate down the hierarchy and apply to all the entities below it.
For instance :</p>
<ul>
<li>adding the <code>Visibility::Hidden</code> component to an object layer will make all objects in it to be hidden</li>
<li>moving an object layer will also move all objects it contains</li>
</ul>
<p>However, there is a special case for tiles.
Since they are not rendered individually but using a &quot;chunk&quot; of several tiles, each individual tile does <strong>not</strong> have a <code>Transform</code> or <code>Visibility</code> component.
We propagate the <code>Transform</code> and <code>Visibility</code> down to the tilemap and <code>bevy_ecs_tilemap</code> take care of the rest to update the corresponding tiles chunk.</p>
<p>Eventhough you could, you should <strong>not</strong> try to add these components to individual tiles:</p>
<ul>
<li>it will not do what you think, everything is handled at the tilemap level anyway</li>
<li>it may hurt performances badly</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="z-ordering"><a class="header" href="#z-ordering">Z-ordering</a></h1>
<p>Since we are working in 2D, the Z-axis will tell which element is in front or behind each other.
You can have a look to <a href="https://bevy-cheatbook.github.io/fundamentals/coords.html">the Bevy cheatbook for a more in-depth explanation</a>.</p>
<h2 id="layers-1"><a class="header" href="#layers-1">Layers</a></h2>
<p>When designing your map under Tiled, you expect that a layer will hide another one which is below in the layer hierarchy.
This is very useful when using isometric tiles for instance, because they usually have several tile layers.</p>
<p>To reproduce this behaviour under Bevy, we add an arbitrary offset on the Z-axis to each layers of the hierarchy.</p>
<p>If we call this offset <code>OFFSET</code>:</p>
<ul>
<li>the top-level layer will have a Z transform of <code>0</code></li>
<li>the second one will have a Z transform of <code>-1x OFFSET</code></li>
<li>the next one of <code>-2x OFFSET</code></li>
<li>the next one of <code>-3x OFFSET</code></li>
<li>etc...</li>
</ul>
<p>By default this offset has a value of <code>+100</code>.
It can be changed by tweaking the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/map/struct.TiledMapLayerZOffset.html"><code>TiledMapLayerZOffset</code></a> component.</p>
<p>Since <code>bevy_ecs_tilemap</code> also adds a small Z-axis offset to adjust how chunk are rendered, you probably don't want to have a &quot;too small&quot; value.</p>
<h2 id="objects-on-a-layer"><a class="header" href="#objects-on-a-layer">Objects on a layer</a></h2>
<p>For a given layer, all objects have the same Z offset.
It can be problematic if two objects displaying something (a Sprite for instance) have the same location.</p>
<p>You may observe a <a href="https://en.wikipedia.org/wiki/Z-fighting">&quot;Z-fighting&quot; issue</a>: since both sprite are at the same depth, there is no way for Bevy to properly determine which one is on top of the other.
Both will be drawn which is likely to produce some flickering.</p>
<p>Currently, there is not an official way to fix that.
You can work-around this issue by using map events and tweak the Z offset of your objects, as shown in the <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/dev/examples/map_events.rs">map events example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-loading-events"><a class="header" href="#map-loading-events">Map loading events</a></h1>
<p>When loading a map or a world, you will receive events to both notifty you about the loading progress and allow you to customize how you map will be displayed.</p>
<p>There are five events :</p>
<ul>
<li>Four events are sent when loading a map or a world :
<ul>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/map/events/struct.TiledMapCreated.html"><code>TiledMapCreated</code></a>: called once the map has finished loading, contains information about the map. Called after the world it belongs to if you actually loaded a world.</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/map/events/struct.TiledLayerCreated.html"><code>TiledLayerCreated</code></a>: called once the map it belongs to has finished loading, contains informations about a specific layer.</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/map/events/struct.TiledObjectCreated.html"><code>TiledObjectCreated</code></a>: called once the map it belongs to has finished loading, contains informations about a specific object on a given layer.</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/map/events/struct.TiledTileCreated.html"><code>TiledTileCreated</code></a>: called once the map it belongs to has finished loading, contains informations about a specific tile on a given layer.</li>
</ul>
</li>
<li>A fifth one is sent only for worlds :
<ul>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/world/events/struct.TiledWorldCreated.html"><code>TiledWorldCreated</code></a>: called once the world has finished loading, contains informations about the world.</li>
</ul>
</li>
</ul>
<p>These events are both regular events and entity-scoped observers.</p>
<p>You can either use an <code>EventReader</code> to read them or a <code>Trigger</code> :</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    commands
        // Spawn a map and attach an observer on it.
        .spawn(TiledMapHandle(
            asset_server.load(&quot;maps/orthogonal/finite.tmx&quot;),
        ))
        // Add an &quot;in-line&quot; observer to detect when the map has finished loading
        .observe(|trigger: Trigger&lt;TiledMapCreated&gt;, map_query: Query&lt;&amp;Name, With&lt;TiledMapMarker&gt;&gt;| {
            if let Ok(name) = map_query.get(trigger.event().entity) {
                info!(&quot;=&gt; Observer TiledMapCreated was triggered for map '{}'&quot;, name);
            }
        });
}

// Just use a regular system which will receive TiledMapCreated events
fn handle_map_event(
    mut map_events: EventReader&lt;TiledMapCreated&gt;,
    map_query: Query&lt;&amp;Name, With&lt;TiledMapMarker&gt;&gt;,
) {
    for e in map_events.read() {
        if let Ok(name) = map_query.get(e.entity) {
            info!(&quot;=&gt; Received TiledMapCreated event for map '{}'&quot;, name);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>All these events are sent <strong>after</strong> the map or world is actually loaded and their components have been inserted, including the ones coming from user properties.</p>
<p>A <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/map_events.rs">dedicated example</a> is available to demonstrate how to use these.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimal-working-example"><a class="header" href="#minimal-working-example">Minimal working example</a></h1>
<p>Add required dependencies to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
bevy = &quot;0.15&quot;
bevy_ecs_tiled = &quot;0.6&quot;
bevy_ecs_tilemap = &quot;0.15&quot;
</code></pre>
<p>Then add the plugin to your app and spawn a map.
Basically, all you have to do is to spawn a <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/struct.TiledMapHandle.html"><code>TiledMapHandle</code></a> with the map asset you want to load (the <code>map.tmx</code> file).
Note that this map asset should be in your local assets folder, as well as required dependencies (such as images or tilesets).
By default, this is the <code>./assets/</code> folder.</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn main() {
    App::new()
        // Add Bevy default plugins
        .add_plugins(DefaultPlugins)
        // Add bevy_ecs_tiled plugin: note that bevy_ecs_tilemap::TilemapPlugin
        // will be automatically added as well if it's not already done
        .add_plugins(TiledMapPlugin::default())
        // Add our startup function to the schedule and run the app
        .add_systems(Startup, startup)
        .run();
}

fn startup(
  mut commands: Commands,
  asset_server: Res&lt;AssetServer&gt;
) {
    // Spawn a Bevy 2D camera
    commands.spawn(Camera2d);

    // Load a map asset and retrieve the corresponding handle
    let map_handle: Handle&lt;TiledMap&gt; = asset_server.load(&quot;map.tmx&quot;);

    // Spawn a new entity with this handle
    commands.spawn(TiledMapHandle(map_handle));
}
</code></pre></pre>
<p>This simplistic example will load a map using default settings.
You can tweak how to load the map by adding various components on the map entity, notably:</p>
<ul>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/enum.TiledMapAnchor.html"><code>TiledMapAnchor</code></a></li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapLayerZOffset.html"><code>TiledMapLayerZOffset</code></a></li>
<li><a href="https://docs.rs/bevy_ecs_tilemap/latest/bevy_ecs_tilemap/map/struct.TilemapRenderSettings.html"><code>TilemapRenderSettings</code></a></li>
<li><a href="https://docs.rs/bevy/latest/bevy/transform/components/struct.Transform.html"><code>Transform</code></a></li>
<li><a href="https://docs.rs/bevy/latest/bevy/render/view/visibility/enum.Visibility.html"><code>Visibility</code></a></li>
</ul>
<p>For instance, here's how you load a map but change its anchor point to be at center instead of bottom-left :</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn spawn_map(
  mut commands: Commands,
  asset_server: Res&lt;AssetServer&gt;
) {
    // You can also spawn your map and associated settings as a single bundle
    commands.spawn((
      TiledMapHandle(asset_server.load(&quot;map.tmx&quot;)),
      TiledMapAnchor::Center,
    ));
}
<span class="boring">}
</span></code></pre></pre>
<p>You can browse the <a href="https://github.com/adrien-bon/bevy_ecs_tiled/tree/main/examples/README.md">examples</a> for more advanced use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawn--despawn--reload-a-map"><a class="header" href="#spawn--despawn--reload-a-map">Spawn / Despawn / Reload a map</a></h1>
<p>These aspects are also covered in the <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/map_reload.rs">dedicated example</a>.</p>
<h2 id="spawn-a-map"><a class="header" href="#spawn-a-map">Spawn a map</a></h2>
<p>Spawning a map is done in two steps:</p>
<ul>
<li>first, load a map asset / a map file using the Bevy <code>AssetServer</code></li>
<li>then, spawn a <code>TiledMapHandle</code> containing a reference to this map asset</li>
</ul>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_map(
    mut commands: Commands,
    asset_server: Res&lt;AssetServer&gt;
) {
    // First, load the map
    let map_handle: Handle&lt;TiledMap&gt; = asset_server.load(&quot;map.tmx&quot;);

    // Then, spawn it, using default settings
    commands.spawn(TiledMapHandle(map_handle));
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that you can perform the initial map loading beforehand (for instance, during your game startup) and  that there is no restriction on the number of maps loaded or spawned at the same time.</p>
<h2 id="despawn-a-map"><a class="header" href="#despawn-a-map">Despawn a map</a></h2>
<p>If you want to despawn a map, the easiest is to actually remove its top-level entity:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn despawn_map(
    mut commands: Commands,
    maps_query: Query&lt;Entity, With&lt;TiledMapMarker&gt;&gt;,
) {
    // Iterate over entities with a TiledMapMarker component
    for map in q_maps.iter() {
        // Despawn these entities, as well as their child entities
        commands.entity(map).despawn_recursive();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>All child entities, like layers and tiles, will automatically be despawned.</p>
<h2 id="respawn--reload-a-map"><a class="header" href="#respawn--reload-a-map">Respawn / reload a map</a></h2>
<p>If you want to reload or respawn a map, you can of course despawn it then spawn it again.
It's tedious, but it works.</p>
<p>However, there is an easier way: you can insert the <code>RespawnTiledMap</code> component to the map entity:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn respawn_map(
    mut commands: Commands,
    maps_query: Query&lt;Entity, With&lt;TiledMapMarker&gt;&gt;,
) {
    if let Ok(entity) =  maps_query.get_single() {
        commands.entity(entity).insert(RespawnTiledMap);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This will load the exact same map but will despawn / spawn again new entities for layers, tiles and objects.
Only the top-level map entity and its components will be persisted.</p>
<p>It means that if you updated components on the children entities (for instance, a tile color or an object position) they will be back as they were when you first loaded the map.
But map components such as <code>TiledMapSettings</code>, <code>TilemapRenderSettings</code> or <code>Transform</code> will be persisted through a respawn.</p>
<p>It could be used to implement a level respawn for instance.</p>
<p>Another use case is to load a new map over an existing one.
An easy way to do that is to just spawn a new <code>TiledMapHandle</code> over an existing map:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_reload(
    mut commands: Commands,
    asset_server: Res&lt;AssetServer&gt;,
    maps_query: Query&lt;Entity, With&lt;TiledMapMarker&gt;&gt;,
) {
    if let Ok(entity) = maps_query.get_single() {
        commands.entity(entity)
            .insert(
                TiledMapHandle(asset_server.load(&quot;other_map.tmx&quot;))
            );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that loading the same map <code>Handle</code> is equivalent to insert the <code>RespawnTiledMap</code> component.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-physics-colliders"><a class="header" href="#add-physics-colliders">Add physics colliders</a></h1>
<p>Tiled allows you to add objects to your map: either directly on an object layer or attached to a tile.
<code>bevy_ecs_tiled</code> can use these objects to automatically spawn physics colliders when loading the map.</p>
<p>We provide two working physics backends: one using <a href="https://github.com/Jondolf/avian"><code>avian</code></a> and another one using <a href="https://github.com/dimforge/bevy_rapier"><code>rapier</code></a>.
They are very close in terms of features regarding <code>bevy_ecs_tiled</code> so feel free to choose the one you prefer.</p>
<p>The API allows you to either use these backends &quot;as-is&quot;, customize them or implement your own backend.</p>
<h2 id="create-collider-objects-in-tiled"><a class="header" href="#create-collider-objects-in-tiled">Create collider objects in Tiled</a></h2>
<p>First step is to have on your map something that we can actually use to spawn a collider :</p>
<ul>
<li>objects attached to an object layer: these are the regular objects you can place on the map when working on an object layer.</li>
<li>objects attached to a tile: for these, you will need to actually edit your tileset and use Tiled <a href="https://doc.mapeditor.org/en/stable/manual/editing-tilesets/#tile-collision-editor">builtin collision editor</a>.</li>
</ul>
<p>These two kinds of objects, eventhough they are handled a bit differently, will actually produce the same result: using the object associated shape we will spawn the corresponding physic collider.</p>
<h2 id="automatically-spawn-colliders"><a class="header" href="#automatically-spawn-colliders">Automatically spawn colliders</a></h2>
<p>In order to automatically spawn colliders from Tiled objects, you need two things:</p>
<ul>
<li>enable the proper feature: either <code>avian</code> or <code>rapier</code>, depending on your backend choice. You can eventually only enable the <code>physics</code> feature, but you'll have to provide your own physics backend.</li>
<li>instanciate the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/physics/struct.TiledPhysicsPlugin.html"><code>TiledPhysicsPlugin</code></a> with the associated <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/physics/trait.TiledPhysicsBackend.html"><code>TiledPhysicsBackend</code></a> of your choice.</li>
</ul>
<p>For instance, to automatically add colliders using the <code>Avian</code> backend:</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

// You must enable the 'avian' feature from bevy_ecs_tiled

fn main() {
    App::new()
        // Load bevy_ecs_tiled main plugin
        .add_plugins(TiledMapPlugin::default())
        // Load bevy_ecs_tiled physics plugin: this is where we select
        // which physics backend to use (in this case, Avian)
        .add_plugins(TiledPhysicsPlugin::&lt;TiledPhysicsAvianBackend&gt;::default())
        // Load Avian main plugin
        .add_plugins(PhysicsPlugins::default().with_length_unit(100.0))
        // Add our systems and run the app!
        .add_systems(Startup, startup)
        .run();
}

// Just load the map as usual:
// colliders are spawned for every objects of your map
fn startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    commands.spawn(Camera2d);
    commands.spawn(TiledMapHandle(asset_server.load(&quot;finite.tmx&quot;)));
}
</code></pre></pre>
<h2 id="objects-filtering"><a class="header" href="#objects-filtering">Objects filtering</a></h2>
<p>By default, we will spawn physics colliders for <strong>all</strong> objects encountered in the map, either regular objects or tiles colliders.
Eventhough it's probably the most common behaviour, you can also fine tune for which objects you want to spawn colliders for.</p>
<p>To do so, we provide the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/physics/struct.TiledPhysicsSettings.html"><code>TiledPhysicsSettings</code></a> component.</p>
<p>This component, which should be added to the map or to the world entity, contains several filters.
Based upon its name, and its parent layer name, we can determine if a particular object should have collider or not.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

// Load the map with custom physics settings (and an Avian backend)
fn startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    commands.spawn(Camera2d);
    commands.spawn((
        TiledMapHandle(asset_server.load(&quot;finite.tmx&quot;)),
        // With this configuration, we will restrict the spawn of colliders to:
        // - regular objects named 'hitbox' or 'collision'
        // - collision objects for tiles in a layer named 'collision'
        // We will not spawn colliders for objects not matching these conditions
        TiledPhysicsSettings::&lt;TiledPhysicsAvianBackend&gt; {
            objects_filter: ObjectNames::Names(vec![String::from(&quot;hitbox&quot;), String::from(&quot;collision&quot;)]),
            tiles_layer_filter: ObjectNames::Names(vec![String::from(&quot;collision&quot;)]),
            ..default()
        },
    ));
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="colliders-aggregation"><a class="header" href="#colliders-aggregation">Colliders aggregation</a></h2>
<p>Tiled uses simple shapes, such as rectangles or ellipses, to define colliders :</p>
<ul>
<li>For tiles, you can use several of these simple shapes to define the whole tile collider</li>
<li>For regular objects (ie. objects inside an object layer), you can either use one of these simple shapes or colliders from an existing tile.</li>
</ul>
<p>In order to reduce the number of physics colliders, and improve overall performances, we will try to merge &quot;simple&quot; colliders together and spawn instead a single &quot;complex&quot; one.
However, keep in mind that if you use complex geometric forms (polygons) for your collisions, we won't be able to merge these colliders and you will still have multiples  colliders, potentially hurting performances.</p>
<p>For a given tiles layer we could have a single physics collider which consists of the aggregation of all tiles colliders it contains.
From a physics point of view we actually have a single collider per layer.</p>
<p>On the other hand, regular objects will always have their own physics collider.
Since they have a <code>Transform</code> and can be moved independently, it would not make sense to have a single colliders for several objects.
In case of &quot;tile objects&quot;, we will still try to merge colliders from the tile.</p>
<h2 id="custom-physics-backend"><a class="header" href="#custom-physics-backend">Custom physics backend</a></h2>
<p>For more advanced use cases, you can eventually define your own physics backend.
All you need to do is to create a struct that implements the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/physics/trait.TiledPhysicsBackend.html"><code>TiledPhysicsBackend</code></a> trait, ie. provide an implementation for the <code>spawn_colliders</code> function and use that backend when adding the <code>TiledPhysicsPlugin&lt;T&gt;</code> to your app.</p>
<p>You can also extend one the provided backend if their implementation have something missing for you.
You can wrap your own implementation around and existing backend (see <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/physics_avian_controller.rs">this example for Avian</a> or <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/physics_rapier$_controller.rs">this one for Rapier</a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-tiled-custom-properties"><a class="header" href="#use-tiled-custom-properties">Use Tiled custom properties</a></h1>
<p>In Tiled we can add &quot;custom properties&quot; on various items such as layers, tiles, objects or maps.</p>
<p>These custom properties can be either:</p>
<ul>
<li>a &quot;standard type&quot;, like a string, an integer, a float, a color, etc...</li>
<li>a &quot;custom type&quot;, which is basically a structure with sub-properties that can either be a &quot;standard type&quot; or another &quot;custom type&quot;</li>
</ul>
<p>Using <code>bevy_ecs_tiled</code>, you can load these &quot;custom properties&quot; in your game and access them as regular Bevy <code>Component</code>, <code>Bundle</code> or even <code>Resource</code>.
Basically, it means that we can define some game logic directly in the Tiled editor to use it in your game with Bevy.</p>
<p>Using this mechanism, we could for instance:</p>
<ul>
<li>associate a &quot;movement cost&quot; to a given tile type</li>
<li>create an object that represent our player or an ennemy</li>
<li>add a generic &quot;trigger zone&quot; that could either be a &quot;damaging zone&quot; or a &quot;victory zone&quot;</li>
<li>... whatever you need for your game!</li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The whole user properties mechanism relies upon Bevy reflect.</p>
<p>To get things running, you first need to :</p>
<ul>
<li>declare the types you want to use as custom properties in your code and make them &quot;reflectable&quot;</li>
<li>run your game once so these types are exported in a <code>.json</code> formated file, readable by Tiled</li>
<li>import this <code>.json</code> file in Tiled editor to make these types available</li>
</ul>
<p>Once done, you will be able to use these types directly in the Tiled editor and when loading your map, <code>Component</code> or <code>Resource</code> corresponding to your types will be automatically inserted.</p>
<p>For a quick demonstration, you can have a look to the <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/properties_basic.rs">dedicated example</a>.</p>
<h2 id="declare-types-to-be-used-as-custom-properties"><a class="header" href="#declare-types-to-be-used-as-custom-properties">Declare types to be used as custom properties</a></h2>
<p>Your Tiled map, layer, tile or object will be represented by a Bevy <code>Entity</code>.
So, it makes sense that if you want to add custom properties to them, these properties should either be a <code>Component</code> or a <code>Bundle</code>.</p>
<p>In order to be usable in Tiled, your custom types must be &quot;reflectable&quot; :</p>
<ul>
<li>your type must derive the <code>Reflect</code> trait</li>
<li>your type must be registered with Bevy</li>
</ul>
<p>Here's a quick example :</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;

// Declare a component and make it &quot;reflectable&quot;
#[derive(Component, Reflect, Default)]
#[reflect(Component, Default)]
struct BiomeInfos {
    block_line_of_sight: bool,
    ty: BiomeType,
}

// Any 'sub-type' which is part of our component must also be &quot;reflectable&quot;
// But it does not have to be a Component
#[derive(Default, Reflect)]
#[reflect(Default)]
enum BiomeType {
    #[default]
    Unknown,
    Forest,
    Plain,
    Moutain,
    Desert,
}

// Finally, register our top-level struct in Bevy registry
fn main() {
    App::new()
        .register_type::&lt;BiomeInfos&gt;();
}
</code></pre></pre>
<p>And that's all for the code part !
Next time you run your app, this <code>Component</code> will be exported in a <code>.json</code> export file which can then be imported in Tiled (more on that in next section).</p>
<p>In the above example, our custom type also derive the <code>Default</code> trait.
It is particulary useful: this way, you don't have to fill all the fields of your custom type when you use it in Tiled.
We will use the type default value to fill the gaps.</p>
<h2 id="import-custom-properties-in-tiled"><a class="header" href="#import-custom-properties-in-tiled">Import custom properties in Tiled</a></h2>
<p>Before you can add custom properties to your map, you will need to export them from your app then import them in Tiled.</p>
<p>When running with the <code>user_properties</code> feature, your app will automatically produce a <code>.json</code> file export of all types registered with Bevy.
By default, this file will be produced in your workspace with the name <code>tiled_types_export.json</code>.
You can change this file name or even disable its production by tweaking the <code>TiledMapPlugin</code> configuration (see <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/struct.TiledMapPluginConfig.html"><code>TiledMapPluginConfig</code></a>).</p>
<p>You can then import this file to Tiled.
To do so, in Tiled, navigate to View -&gt; Custom Types Editor:</p>
<p><img src="guides/images/properties_view-types.png" alt="view-custom-types" /></p>
<p>Click on the <code>Import</code> button and load your file:</p>
<p><img src="guides/images/properties_import-types.png" alt="import-custom-types" /></p>
<p>Once it is done, you will be able to see all the custom types that you have imported from your application.
Note that it concerns all the types that derive the <code>Reflect</code> trait: there can be quite a lot !</p>
<p><img src="guides/images/properties_custom-type.png" alt="view-custom-types" /></p>
<h2 id="add-custom-properties-to-your-map"><a class="header" href="#add-custom-properties-to-your-map">Add custom properties to your map</a></h2>
<p>Once this setup is done, you can add custom properties to your map.</p>
<p>You must select the element you want to add a property on, right-click in the &quot;Custom Properties&quot; panel, then select &quot;Add Property&quot; :</p>
<p><img src="guides/images/properties_add-property.png" alt="add-property" /></p>
<p>This will display a popup from which you can select the type you want to add to this element and give it a name.</p>
<p>For instance, you can add the <code>BiomeInfos</code> type from previous example :</p>
<p><img src="guides/images/properties_biome-infos.png" alt="biome-infos" /></p>
<p>And finally update the values that make sense for this particular element.
When you load the map, this element entity will have the proper <code>Component</code> with the value you set here.</p>
<p>You should only add properties imported from Bevy: adding ones that you created only in Tiled will not be loaded in Bevy if they do not contain actual Bevy <code>Component</code>s.</p>
<h2 id="special-considerations"><a class="header" href="#special-considerations">Special considerations</a></h2>
<p>You can add custom properties to different Tiled elements, such as objects, layers or the map itself.
To add properties on tiles, you should edit the tileset itself.
For more information on how to do add custom properties, see the <a href="https://doc.mapeditor.org/en/stable/manual/custom-properties/">official Tiled documentation</a>.</p>
<p>Finally, you are not limited to Bevy <code>Component</code>s, you can also add <code>Resource</code>s to your map.
Since <code>Resource</code>s are not attached to a particular entity and they are shared accros your app, we chose to restrict their usage only as Tiled map properties.
If you add a resource to another Tiled element it will just be ignored.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-your-project"><a class="header" href="#debug-your-project">Debug your project</a></h1>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>Bevy uses the <code>tracing</code> crate for logging, which is very powerful in debugging and profiling, you can find more information in the <a href="https://docs.rs/tracing/">official documentation</a>.</p>
<p>We recommend to enable the <code>trace</code> level in your application to get more informations about what's happening, just set the <code>RUST_LOG</code> environment variable to <code>trace</code>:</p>
<pre><code class="language-sh">RUST_LOG=trace cargo run
</code></pre>
<p>But this will be very verbose, so you can also filter the logs to only display the informations you need:</p>
<pre><code class="language-sh">RUST_LOG=bevy_ecs_tiled=trace cargo run
</code></pre>
<p>This will only display logs from the <code>bevy_ecs_tiled</code> crate in <code>trace</code> level.</p>
<h2 id="bevy_ecs_tiled-debug-plugins"><a class="header" href="#bevy_ecs_tiled-debug-plugins"><code>bevy_ecs_tiled</code> debug plugins</a></h2>
<p>When the <code>debug</code> feature is enabled, <code>bevy_ecs_tiled</code> provides several debug plugins.</p>
<p>You can easily turn them all by adding the <code>TiledDebugPluginGroup</code> to your app :</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn main() {
    App::new()
        .add_plugins(TiledDebugPluginGroup)
        .run();
}
</code></pre></pre>
<p>Or add them individually :</p>
<ul>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/debug/objects/index.html"><code>TiledDebugObjectsPlugin</code></a> : display a Bevy <code>Gizmos</code> to indicate where Tiled objects are</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/debug/tiles/index.html"><code>TiledDebugTilesPlugin</code></a> : display the <code>bevy_ecs_tilemap</code> index, ie. <code>Tilepos</code> on each tile</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/debug/world_chunk/index.html"><code>TiledDebugWorldChunkPlugin</code></a> : display a Bevy <code>Gizmos</code> for each map boundary and world render chunk</li>
</ul>
<p>More informations in the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/debug/index.html">API reference</a>.</p>
<h2 id="3rdparty"><a class="header" href="#3rdparty">3rdparty</a></h2>
<h3 id="bevy-inspector-egui"><a class="header" href="#bevy-inspector-egui"><code>bevy-inspector-egui</code></a></h3>
<p>This may be obvious but this plugin is a must have for debugging.</p>
<p>Just add the required dependency in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
bevy-inspector-egui = &quot;0.30&quot;
</code></pre>
<p>Then add the <code>WorldInspectorPlugin</code> to your application:</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_inspector_egui::quick::WorldInspectorPlugin;

fn main() {
    App::new()
        .add_plugins(WorldInspectorPlugin::new())
        .run();
}
</code></pre></pre>
<p>Now, you can browse components from all entities spawned in your game.</p>
<p>More informations on the project <a href="https://github.com/jakobhellermann/bevy-inspector-egui">github page</a>.</p>
<h3 id="physics-plugins"><a class="header" href="#physics-plugins">Physics plugins</a></h3>
<p>Both Avian and Rapier provide their own way of debugging.
It can be very useful, especially when working with colliders.
Note that physics debugging is enabled by default in all <code>bevy_ecs_tiled</code> examples using physics.</p>
<p>To enable physics debugging in Avian, you need to simply add the corresponding plugin:</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use avian2d::prelude::*;

fn main() {
    App::new()
        // Add Avian regular plugin
        .add_plugins(PhysicsPlugins::default().with_length_unit(100.0))
        // Add Avian debug plugin
        .add_plugins(PhysicsDebugPlugin::default())
        .run();
}
</code></pre></pre>
<p>For Rapier, you need to enable a debug plugin:</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_rapier2d::prelude::*;

fn main() {
    App::new()
        // Add Rapier regular plugin
        .add_plugins(RapierPhysicsPlugin::&lt;NoUserData&gt;::pixels_per_meter(100.0))
        // Add Rapier debug plugin
        .add_plugins(RapierDebugRenderPlugin::default())
        .run();
}
</code></pre></pre>
<p>And you also need to enable either the <code>debug-render-2d</code> feature on <code>bevy_rapier2d</code> crate or the <code>rapier_debug</code> feature on <code>bevy_ecs_tiled</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-v05x-to-v06x"><a class="header" href="#from-v05x-to-v06x">From v0.5.X to v0.6.X</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Version 0.6 brings new features such as Tiled world support and tiles colliders aggregation (which should improve performances when working with physics), bugfixes (mostly for infinite maps) and a rework of the API to make it more user-friendly.</p>
<p>For instance, we now use entity-scoped observers for our loading events instead of global ones, so it's easier to work with several maps at the same time.</p>
<p>Code base have also been re-organized to better fit the new world feature, but it should not impact end-users.</p>
<h2 id="plugin-instanciation"><a class="header" href="#plugin-instanciation">Plugin instanciation</a></h2>
<p>You don't need to manually instanciate the <code>TilemapPlugin</code> from <code>bevy_ecs_tilemap</code>.
It is now automatically done when adding <code>TiledMapPlugin</code> to your application if not already done.</p>
<p>Before :</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;
use bevy_ecs_tilemap::prelude::*;

fn main() {
    App::new()
        // Main plugin from bevy_ecs_tilemap
        .add_plugins(TilemapPlugin)
        // Main plugin from bevy_ecs_tiled
        .add_plugins(TiledMapPlugin::default());
}
</code></pre></pre>
<p>After :</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn main() {
    App::new()
        // Main plugin from bevy_ecs_tiled:
        // implicitely load bevy_ecs_tilemap main plugin
        .add_plugins(TiledMapPlugin::default());
}
</code></pre></pre>
<h2 id="map-loading-events-1"><a class="header" href="#map-loading-events-1">Map loading events</a></h2>
<p>Map loading events have been heavily updated :</p>
<ul>
<li>Instead of using a single global observer, we now trigger an entity-scoped observer <strong>and</strong> send a regular event</li>
<li>Only use &quot;safe&quot; methods to retrieve data from events (no more <code>unwrap()</code> internally)</li>
<li>Store an <code>AssetId&lt;TiledMap&gt;</code> instead of a <code>Handle&lt;TiledMap&gt;</code> to acces Tiled map data, enforce the fact that we store a weak reference in the event and not a strong one.</li>
<li>Some fields from the events have been renamed</li>
</ul>
<p>Before :</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn main() {
    App::new()
        .add_plugins(TiledMapPlugin::default())
        .add_systems(Startup, startup)
        // Previously, we could only use a global observer
        .add_observer(|trigger: Trigger&lt;TiledMapCreated&gt;, map_asset: Res&lt;Assets&lt;TiledMap&gt;&gt;| {
            // Previously, the method to retrieve map data would panic in case of error
            let map = trigger.event().map(&amp;map_asset);
            info!(&quot;(observer) Loaded map: {:?}&quot;, map);
        });
}

fn startup(
  mut commands: Commands,
  asset_server: Res&lt;AssetServer&gt;
) {
    commands.spawn(TiledMapHandle(asset_server.load(&quot;map.tmx&quot;)));
}
</code></pre></pre>
<p>After :</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn main() {
    App::new()
        .add_plugins(TiledMapPlugin::default())
        .add_systems(Startup, startup)
        .add_systems(Update, read_map_events);
}

fn startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    commands
        .spawn(TiledMapHandle(asset_server.load(&quot;map.tmx&quot;)))
        // Now, you can use an entity-scoped observer
        .observe(
            |trigger: Trigger&lt;TiledMapCreated&gt;, map_asset: Res&lt;Assets&lt;TiledMap&gt;&gt;| {
                // Now, this method return an Option&lt;T&gt; and don't panic in case of error
                if let Some(map) = trigger.event().get_map(&amp;map_asset) {
                    info!(&quot;(observer) Loaded map: {:?}&quot;, map);
                }
            },
        );
}

// Or a regular event
fn read_map_events(mut map_events: EventReader&lt;TiledMapCreated&gt;, map_asset: Res&lt;Assets&lt;TiledMap&gt;&gt;) {
    for event in map_events.read() {
        if let Some(map) = event.get_map(&amp;map_asset) {
            info!(&quot;(event) Loaded map: {:?}&quot;, map);
        }
    }
}
</code></pre></pre>
<p>For more detailled informations, you should have a look to <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/map_events.rs">the dedicated example</a> or <a href="migrations/../design/map_events.html">the guide</a>.</p>
<h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<p>To get tile colliders aggregation working, we had to rework a bit the physics API :</p>
<ul>
<li>function <code>TiledPhysicsBackend::spawn_collider()</code> can now spawn several colliders per call. To reflect that it now returns a <code>Vec&lt;TiledColliderSpawnInfos&gt;</code> instead of an <code>Option&lt;TiledColliderSpawnInfos&gt;</code>. Also, it now takes a <code>TiledNameFilter</code> as input parameter to filter out unwanted objects</li>
<li>remove the <code>TiledColliderCreated</code> events which added some complexity but did not have actual usage</li>
<li>rename <code>TiledColliderSourceType</code> to <code>TiledCollider</code> and remove the <code>Tile</code> variant in favor of the new <code>TilesLayer</code></li>
<li><code>TiledPhysicsBackend</code> now requires to implement the <code>Clone</code>, <code>Reflect</code> and <code>Debug</code> traits</li>
<li>rename Rename <code>ObjectNameFilter</code> to <code>TiledNameFilter</code> since we also use it for layer name</li>
</ul>
<h2 id="schedules"><a class="header" href="#schedules">Schedules</a></h2>
<p>To prevent potential Bevy error <a href="https://bevyengine.org/learn/errors/b0003/">B0003</a> we changed a bit how our systems are scheduled.</p>
<p>Before, everything was done in the <code>Update</code> schedule.
Now, we schedule systems that spawn entities in the <code>PreUpdate</code> schedule and systems that could despawn entities in the <code>PostUpdate</code> schedule.</p>
<h2 id="misc-api-changes"><a class="header" href="#misc-api-changes">Misc API changes</a></h2>
<ul>
<li>rename <code>TiledIdStorage</code> component to <code>TiledMapStorage</code> so we are consistent with the new world API</li>
<li>rename <code>ObjectNameFilter</code> type to <code>TiledNameFilter</code> since we also use it for layer names</li>
<li>rename <code>from_tiled_coords_to_bevy</code> function to <code>from_tiled_position_to_world_space</code></li>
<li>split <code>TiledMapSettings</code> component in two: <code>TiledMapAnchor</code> and <code>TiledMapLayerZOffset</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-v04x-to-v05x"><a class="header" href="#from-v04x-to-v05x">From v0.4.X to v0.5.X</a></h1>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Version 0.5 updates the crate for Bevy v0.15.
It notably takes advantage of the new <code>required_component</code> feature to simplify the crate API.</p>
<p>Also, this version provide some fixes related to user properties.
If you are using them, you should reload your export file.</p>
<h2 id="bevy-v015-update"><a class="header" href="#bevy-v015-update">Bevy v0.15 update</a></h2>
<p><a href="https://bevyengine.org/learn/migration-guides/0-14-to-0-15/">Bevy official migration guide</a></p>
<h2 id="misc-changes"><a class="header" href="#misc-changes">Misc changes</a></h2>
<h3 id="tiledmapsettings-update"><a class="header" href="#tiledmapsettings-update"><code>TiledMapSettings</code> update</a></h3>
<p><code>map_initial_transform</code> and <code>map_initial_visibility</code> have been removed from <code>TiledMapSettings</code>.</p>
<p>If you want to tweak your map positioning or visibility, you should instead directly insert corresponding <code>Transform</code> or <code>Visibility</code> components on the map entity.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let map_handle: Handle&lt;TiledMap&gt; = asset_server.load(&quot;map.tmx&quot;);
    commands.spawn((
        TiledMapHandle(map_handle),
        TiledMapSettings {
            map_initial_transform: Transform::from_xyz(150., 100., 0.),
            map_initial_visibility: Visibility::Hidden,
            ..Default::default()
        },
    ));
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let map_handle: Handle&lt;TiledMap&gt; = asset_server.load(&quot;map.tmx&quot;);
    commands.spawn((
        TiledMapHandle(map_handle),
        Transform::from_xyz(150., 100., 0.),
        Visibility::Hidden,
    ));
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-v03x-to-v04x"><a class="header" href="#from-v03x-to-v04x">From v0.3.X to v0.4.X</a></h1>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Version 0.4 was initially motivated by an update to the way we handle user properties but ended as a major overhaul of the plugin to provide a better API and to give more control to the user.</p>
<h2 id="plugin-instanciation-1"><a class="header" href="#plugin-instanciation-1">Plugin instanciation</a></h2>
<p>The plugin now has an associated configuration, which you need to provide when you add it to your application.</p>
<p>The easiest way is to use the default configuration value :</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn main() {
    App::new()
        // You still need the bevy_ecs_tilemap plugin
        .add_plugins(TilemapPlugin)
        // And now, you have to provide a configuration for bevy_ecs_tiled plugin
        .add_plugins(TiledMapPlugin::default())
        .run();
}
</code></pre></pre>
<p>The plugin configuration is described in the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/struct.TiledMapPluginConfig.html">API reference</a></p>
<h2 id="tiled-map-spawn-and-configuration"><a class="header" href="#tiled-map-spawn-and-configuration">Tiled map spawn and configuration</a></h2>
<p>The plugin entry point, ie. the <code>TiledMapBundle</code> bundle is gone.
It was cumbersome and did not allow for a proper separation of concerns (for instance, for physics).</p>
<p>Also, the <code>Handle&lt;TiledMap&gt;</code> type is not a Bevy component anymore.
It was done in order to anticipate expected changes in Bevy where <code>Handle&lt;T&gt;</code> won't be able to derive the <code>Component</code> trait anymore.</p>
<p>Anyway, the new way to spawn a map is now easier: you just have to spawn a <code>TiledMapHandle</code> referencing your .TMX file asset:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    // Load the map: ensure any tile / tileset paths are relative to assets/ folder
    let map_handle: Handle&lt;TiledMap&gt; = asset_server.load(&quot;map.tmx&quot;);

    // Spawn the map with default options
    commands.spawn(TiledMapHandle(map_handle));
}
<span class="boring">}
</span></code></pre></pre>
<p>You can customize various settings about how to load the map by inserting the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapSettings.html"><code>TiledMapSettings</code></a> component on the map entity.</p>
<h2 id="tiled-user-properties"><a class="header" href="#tiled-user-properties">Tiled user properties</a></h2>
<p>Before this change, you had to define your custom types both in Tiled and in your rust code.
It was not user-friendly and error-prone.</p>
<p>Now, we take advantage of <code>bevy_reflect</code> to generate a file containing all the types known to Bevy.
This file can be imported in Tiled so you can use these types directly in the editor.</p>
<p>Migrating from the old implementation should be straight-forward.</p>
<p>First, you need need to update your custom types so they actually implement the <code>Reflect</code> trait :</p>
<ul>
<li>remove <code>#[derive(TiledObject)]</code>, <code>#[derive(TiledCustomTile)]</code>, <code>#[derive(TiledClass)]</code> and <code>#[derive(TiledEnum)]</code> derived traits. Make sure to also remove associated attributes.</li>
<li>add <code>#[derive(Reflect)]</code> derive trait on the types you want to use in Tiled.</li>
<li>make sure your components have the <code>#[reflect(Component)]</code> attribute</li>
</ul>
<p>Then, in your main / in your plugin setup, you then need to register your types with Bevy :</p>
<ul>
<li>replace calls to <code>register_tiled_object::&lt;T&gt;()</code> with calls to <code>register_type::&lt;T&gt;()</code>.</li>
<li>replace calls to <code>register_tiled_custom_tile::&lt;T&gt;()</code> with calls to <code>register_type::&lt;T&gt;()</code>.</li>
</ul>
<p>The final step is to actually generate the types import file (run your game once) and import the types to Tiled.
Note that you may have to update your map / your tilesets to use the new types you just imported.</p>
<p><a href="migrations/../guides/properties.html"><strong>A dedicated guide about how to setup user properties is available in this book</strong></a>.</p>
<h2 id="tiled-physics"><a class="header" href="#tiled-physics">Tiled physics</a></h2>
<p>Eventhough functionnalities around physics did not change much, the internals have been completely reworked and the API was updated a bit.</p>
<p>Notably, now you need to instanciate another plugin and specify which physics backend you want to use.
<a href="migrations/../guides/physics.html">The physics section of the book should get you through</a>.</p>
<h2 id="map-events"><a class="header" href="#map-events">Map events</a></h2>
<p>This is a new feature of this version which gives more control to the user over what he wants to do with a Tiled map.
<a href="migrations/../design/map_events.html">More information in the dedicated section</a></p>
<h2 id="misc-changes-1"><a class="header" href="#misc-changes-1">Misc changes</a></h2>
<h3 id="enum-mappositioning"><a class="header" href="#enum-mappositioning"><code>enum MapPositioning</code></a></h3>
<p>Both enum name and fields name have been updated to better reflect what they actually do.
You should now use the new <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/enum.LayerPositioning.html"><code>LayerPositioning</code></a> enum.</p>
<h3 id="fn-from_isometric_coords_to_bevy"><a class="header" href="#fn-from_isometric_coords_to_bevy"><code>fn from_isometric_coords_to_bevy()</code></a></h3>
<p>Parameters <code>tiled_position: Vec2</code> and <code>iso_coords: IsoCoordSystem</code> have been swapped for better consistency with other utility functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-links"><a class="header" href="#useful-links">Useful links</a></h1>
<p>Here is an unordered list of useful resources that may help when working on a 2D tile-base game.</p>
<p>Feel free to suggest any other link!</p>
<h2 id="notable-crates"><a class="header" href="#notable-crates">Notable crates</a></h2>
<ul>
<li><a href="https://github.com/bevyengine/bevy"><code>bevy</code></a>: the Bevy engine</li>
<li><a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code></a>: the crate we use for rendering our tiles</li>
<li><a href="https://github.com/mapeditor/rs-tiled"><code>rs-tiled</code></a>: official Tiled rust bindings</li>
<li><a href="https://github.com/Trouv/bevy_ecs_ldtk"><code>bevy_ecs_ldtk</code></a>: an equivalent of <code>bevy_ecs_tiled</code> but for the <a href="https://ldtk.io/">LDTK</a> map editor</li>
<li><a href="https://github.com/ManevilleF/hexx"><code>hexx</code></a>: an hexagonal tools lib for stuff like path-finding or hex coordinates manipulation</li>
<li><a href="https://github.com/aevyrie/bevy_mod_picking/"><code>bevy_mod_picking</code></a>: a flexible set of plugins that add picking functionality to your bevy app</li>
<li><a href="https://github.com/zacryol/bevy_picking_tilemap"><code>bevy_picking_tilemap</code></a>: provides a <a href="https://github.com/aevyrie/bevy_mod_picking/"><code>bevy_mod_picking</code></a> backend to add integration with <a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code></a>, enabling individual Tile entities to receive the picking events</li>
<li><a href="https://github.com/Jondolf/avian"><code>avian</code></a>: Avian physic backend</li>
<li><a href="https://github.com/dimforge/bevy_rapier"><code>bevy_rapier</code></a>: Rapier physic backend</li>
</ul>
<h2 id="notable-resources"><a class="header" href="#notable-resources">Notable resources</a></h2>
<ul>
<li><a href="https://bevyengine.org/">Bevy official website</a>: lots of examples and learning materials</li>
<li><a href="https://docs.rs/bevy/latest/bevy/">Bevy API reference</a></li>
<li><a href="https://bevy-cheatbook.github.io/">Unofficial Bevy Cheat Book</a>: one the best resource to learn Bevy</li>
<li><a href="https://www.mapeditor.org/">Tiled official website</a>: to get the latest Tiled version and read associated documentation</li>
<li><a href="https://www.redblobgames.com/">Red Blob Games</a>: collections of tutorials on various gamedev topics, especially the <a href="https://www.redblobgames.com/grids/hexagons/">hexagonal grids reference</a></li>
<li><a href="https://clintbellanger.net/articles/isometric_math/">Some maths regarding isometric tiles</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>If you would like to contribute but you're unsure where to start, here is a short wishlist and some notes on how to get started.</p>
<p>First, you can have a look at <a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues">GH issues</a>.
More specifically, the ones that are:</p>
<ul>
<li><a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues?q=is%3Aopen+is%3Aissue+label%3Aenhancement">tagged with <code>enhancement</code> label</a></li>
<li><a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues?q=is%3Aopen+is%3Aissue+label%3Alimitation">tagged with <code>limitation</code> label</a></li>
</ul>
<p>If you feel like you can tackle on of these, please, feel free to submit a PR!</p>
<p>Helping other users, respond to issues, help review PRs or just openning new issues is also very helpful !</p>
<p>Also, another way of helping is to contribute on crates we rely on, namely <a href="https://github.com/mapeditor/rs-tiled"><code>rs-tiled</code></a> and <a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code></a>, or anything else in the Bevy ecosystem.</p>
<h2 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution guidelines</a></h2>
<p>If you submit a PR, please make sure that:</p>
<ul>
<li>the CI is green: you can locally run the <code>./ci_check.sh</code> script</li>
<li>you add proper in-code documentation</li>
<li>you update the <code>CHANGELOG.md</code> file with a description of your fix</li>
<li>if you add a new example, update the <code>examples/README.md</code> file with a description of your example and the <code>Cargo.toml</code> file with your example name (and any feature it may need)</li>
<li>if you add a new map, update the <code>assets/README.md</code> file with your map characteristics</li>
<li>if you add a new asset, update the &quot;Assets credits&quot; section of the <code>README.md</code> file and make sure that you actually have the right to use it!</li>
</ul>
<p>Thanks in advance! :)</p>
<div style="break-before: page; page-break-before: always;"></div><meta http-equiv="Refresh" content="0; url='https://docs.rs/bevy_ecs_tiled/'" />
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>

<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>bevy_ecs_tiled Documentation</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="FAQ.html">FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Design and explanation</li><li class="chapter-item expanded "><a href="design/why-tiled.html"><strong aria-hidden="true">1.</strong> Why using Tiled ?</a></li><li class="chapter-item expanded "><a href="design/entities_tree.html"><strong aria-hidden="true">2.</strong> Entities tree and marker components</a></li><li class="chapter-item expanded "><a href="design/z_order.html"><strong aria-hidden="true">3.</strong> Layers Z-ordering</a></li><li class="chapter-item expanded "><a href="design/map_events.html"><strong aria-hidden="true">4.</strong> Map loading events</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Coordinates conversion between Tiled and Bevy</div></li><li class="chapter-item expanded affix "><li class="part-title">How-To's</li><li class="chapter-item expanded "><a href="guides/minimal.html"><strong aria-hidden="true">6.</strong> Minimal working example</a></li><li class="chapter-item expanded "><a href="guides/spawn_reload.html"><strong aria-hidden="true">7.</strong> Spawn / Despawn / Reload a map</a></li><li class="chapter-item expanded "><a href="guides/physics.html"><strong aria-hidden="true">8.</strong> Add physics colliders</a></li><li class="chapter-item expanded "><a href="guides/properties.html"><strong aria-hidden="true">9.</strong> Use Tiled custom properties</a></li><li class="chapter-item expanded "><a href="guides/debug.html"><strong aria-hidden="true">10.</strong> Debug your project</a></li><li class="chapter-item expanded affix "><li class="part-title">Migration guides</li><li class="chapter-item expanded "><a href="migrations/v0_5.html"><strong aria-hidden="true">11.</strong> From v0.4.X to v0.5.X</a></li><li class="chapter-item expanded "><a href="migrations/v0_4.html"><strong aria-hidden="true">12.</strong> From v0.3.X to v0.4.X</a></li><li class="chapter-item expanded affix "><li class="part-title">Miscellaneous</li><li class="chapter-item expanded "><a href="misc/useful-links.html"><strong aria-hidden="true">13.</strong> Useful links</a></li><li class="chapter-item expanded "><a href="misc/contributing.html"><strong aria-hidden="true">14.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="misc/api-reference.html"><strong aria-hidden="true">15.</strong> API reference</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">bevy_ecs_tiled Documentation</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/adrien-bon/bevy_ecs_tiled"><code>bevy_ecs_tiled</code></a> is a <a href="https://bevyengine.org/">Bevy</a> plugin for working with 2D tilemaps created with the <a href="https://www.mapeditor.org/">Tiled</a> map editor.</p>
<p>It relies upon:</p>
<ul>
<li>the official <a href="https://github.com/mapeditor/rs-tiled">Tiled Rust bindings</a> to load Tiled map files</li>
<li>the <a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code> crate</a> to perform rendering</li>
</ul>
<p>Each tile or object is represented by a Bevy entity:</p>
<ul>
<li>layers are children of the tilemap entity</li>
<li>tiles and objects are children of layers</li>
</ul>
<p><code>Visibility</code> and <code>Transform</code> are inherited: map -&gt; layer -&gt; tile / object</p>
<hr />
<p><strong>Disclaimer:</strong> both this book and the whole crate have been heavilly inspired by the <a href="https://github.com/Trouv/bevy_ecs_ldtk"><code>bevy_ecs_ldtk</code> crate</a>, which is basically the equivalent of <code>bevy_ecs_tiled</code> but for the <a href="https://ldtk.io/">LDTK</a> map editor.
Thanks for the inspiration! :)</p>
<hr />
<h2 id="purpose-of-this-book"><a class="header" href="#purpose-of-this-book">Purpose of this book</a></h2>
<p>This book aims to give you a better understanding of how <a href="https://github.com/adrien-bon/bevy_ecs_tiled"><code>bevy_ecs_tiled</code></a> works, what you can achieve with it and how you can do it.</p>
<p>It will focus on concepts, design concerns and basic tutorials.
If you need an API reference, please have a look at the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/"><code>bevy_ecs_tiled</code> API reference</a>.</p>
<p>Finally, this book assume you already have some sort of knowledge about <a href="https://bevyengine.org/">Bevy</a> and <a href="https://www.mapeditor.org/">Tiled</a> map editor.
There are already some good documentations available on these topics and some resources are referenced <a href="misc/useful-links.html">in the dedicated section</a>.</p>
<h2 id="architecture-of-this-book"><a class="header" href="#architecture-of-this-book">Architecture of this book</a></h2>
<p>This book is divided in several categories:</p>
<ul>
<li><strong>Design and explanation</strong>: how does the plugin work and why some technical choices have been made;</li>
<li><strong>How-To's</strong>: in-depth tutorials about a specific aspect of  the plugin;</li>
<li><strong>Migration guides</strong>: migration guides for specific versions;</li>
<li><strong>Miscellaneous</strong>: other topics that did not fit in other categories.</li>
</ul>
<p>Good reading ! :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="what-is-the-current-status-of-the-crate-"><a class="header" href="#what-is-the-current-status-of-the-crate-">What is the current status of the crate ?</a></h2>
<p>While the crate is already definitely usable, it is still under active development.</p>
<p>Expect bugs and missing features !</p>
<p>I plan to follow semver and try to only break API upon new Bevy release.</p>
<h2 id="what-kind-of-maps-are-supported-"><a class="header" href="#what-kind-of-maps-are-supported-">What kind of maps are supported ?</a></h2>
<p>Currently, we support :</p>
<ul>
<li>orthogonal maps</li>
<li>(mostly) isometric &quot;diamond&quot; maps</li>
<li>hexagonal &quot;flat-top&quot; maps</li>
<li>hexagonal &quot;pointy-top&quot; maps</li>
</ul>
<p>Isometric &quot;diamond&quot; maps currently have an issue with colliders not having the proper shape (see <a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues/32">GH issue #32</a>).</p>
<p>Isometric &quot;staggered&quot; maps are not supported at all (see <a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues/31">GH issue #31</a>).</p>
<h2 id="is-it-possible-to-automatically-add-physics-colliders-"><a class="header" href="#is-it-possible-to-automatically-add-physics-colliders-">Is it possible to automatically add physics colliders ?</a></h2>
<p>Yes, see the <a href="guides/physics.html">dedicated guide</a>.</p>
<p>We currently support both <a href="https://github.com/Jondolf/avian">Avian</a> and <a href="https://github.com/dimforge/bevy_rapier">Rapier</a> physics backend.</p>
<h2 id="is-it-possible-to-use-tiled-custom-properties-"><a class="header" href="#is-it-possible-to-use-tiled-custom-properties-">Is it possible to use Tiled &quot;custom properties&quot; ?</a></h2>
<p>Yes, see the <a href="guides/properties.html">dedicated guide</a>.</p>
<h2 id="im-using-an-isometric-map-and-it-seems-all-messed-up"><a class="header" href="#im-using-an-isometric-map-and-it-seems-all-messed-up">I'm using an isometric map and it seems all messed up!</a></h2>
<p>Make sure you are actually using a &quot;diamond&quot; map and not a &quot;staggered&quot; one (which are not supported).</p>
<p>Also, for isometric maps, you may want to tweak the <code>TilemapRenderSettings</code> Component from <code>bevy_ecs_tilemap</code>.
More information in the <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/orientation_isometric.rs#L34">isometric maps example</a></p>
<h2 id="how-to-enable-map-hot-reload-"><a class="header" href="#how-to-enable-map-hot-reload-">How to enable map hot-reload ?</a></h2>
<p>You need to enable Bevy <code>file_watcher</code> feature.
<code>bevy_ecs_tiled</code> will then be able to automatically reload a map that was updated with Tiled.</p>
<h2 id="i-found-a-bug-what-should-i-do-"><a class="header" href="#i-found-a-bug-what-should-i-do-">I found a bug! What should I do ?</a></h2>
<p>Please have a look to <a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues">already openned issues</a> and if it does not already exists, please fill a new one !</p>
<h2 id="i-want-to-add-a-new-feature-thats-not-yet-in-the-crate"><a class="header" href="#i-want-to-add-a-new-feature-thats-not-yet-in-the-crate">I want to add a new feature that's not yet in the crate!</a></h2>
<p>Great news!
Please have a look to <a href="misc/contributing.html">the dedicated section</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-using-tiled-"><a class="header" href="#why-using-tiled-">Why using Tiled ?</a></h1>
<p><a href="https://www.mapeditor.org/">Tiled</a> may feel a bit outdated in terms of &quot;look and feel&quot;, especially when compared with more modern map editor tools like <a href="https://ldtk.io/">LDTK</a>.
However it has <strong>a lot</strong> of features which make it very interesting.</p>
<p>If we compare with <a href="https://ldtk.io/">LDTK</a>, they both have a set of powerful features like:</p>
<ul>
<li>auto-tiling</li>
<li>adding gameplay informations to map tiles and objects</li>
<li>working with worlds</li>
</ul>
<p>But <a href="https://www.mapeditor.org/">Tiled</a> also have a set of unique features:</p>
<ul>
<li>support for both isometric and hexagonal maps</li>
<li>native support for animated tiled</li>
</ul>
<p>Since I specifically wanted to work with hexagonal maps the choice was obvious for me!</p>
<p>However, if it's not your case and you just want to use orthogonal map, you could give a shot at using <a href="https://ldtk.io/">LDTK</a> instead, especially using the <a href="https://github.com/Trouv/bevy_ecs_ldtk"><code>bevy_ecs_ldtk</code> crate</a>.
Or stay with <a href="https://www.mapeditor.org/">Tiled</a>, it also works :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities-tree-and-marker-components"><a class="header" href="#entities-tree-and-marker-components">Entities tree and marker components</a></h1>
<p>When a map is loaded, it spawns <strong>a lot</strong> of entities: for the map, for layers, for tiles, for objects, for colliders, ...
These entites are organized in a <a href="https://bevy-cheatbook.github.io/fundamentals/hierarchy.html">parent / child hierarchy</a>.</p>
<p>It notably brings the capability to inherit some of the component down the tree.
For instance, if you change the <code>Visibility</code> of an entity, it will automatically apply to all entities below in the hierarchy.</p>
<p>It also helps to keep things nice and clean.</p>
<h2 id="tree-hierarchy"><a class="header" href="#tree-hierarchy">Tree hierarchy</a></h2>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p>At the top of the tree, there is the map.
It notably holds the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/struct.TiledMapHandle.html"><code>TiledMapHandle</code></a> pointing to your .TMX file and all the settings that apply to it.
It can be easily identified using a dedicated marker component: <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapMarker.html"><code>TiledMapMarker</code></a>.</p>
<h3 id="layers"><a class="header" href="#layers">Layers</a></h3>
<p>Below the map, we have the layers.
They can be of different kinds, which each have their own marker component:</p>
<ul>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapObjectLayer.html"><code>TiledMapObjectLayer</code></a>: for objects layer.</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapTileLayer.html"><code>TiledMapTileLayer</code></a>: for tiles layer.</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapGroupLayer.html"><code>TiledMapGroupLayer</code></a>: for group layer (not supported for now).</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapImageLayer.html"><code>TiledMapImageLayer</code></a>: for image layer (not supported for now).</li>
</ul>
<p>All of them are also identified by the same generic marker: <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapLayer.html"><code>TiledMapLayer</code></a>.</p>
<h3 id="objects--tiles"><a class="header" href="#objects--tiles">Objects &amp; Tiles</a></h3>
<p>Objects are directly below their <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapObjectLayer.html"><code>TiledMapObjectLayer</code></a>.
They are identified by a <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapObject.html"><code>TiledMapObject</code></a> marker.</p>
<p>For tiles, it's a little more complicated.
Below the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapTileLayer.html"><code>TiledMapTileLayer</code></a>, we first have one <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapTileLayerForTileset.html"><code>TiledMapTileLayerForTileset</code></a> per tileset in the map.
Finally, below these, we find the actual <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapTile.html"><code>TiledMapTile</code></a> which correspond to every tiles in the layer, for a given tileset.</p>
<h3 id="physics-colliders"><a class="header" href="#physics-colliders">Physics colliders</a></h3>
<p>At the end of the hierarchy, we find physics colliders.
They are spawned below they &quot;source&quot;, ie. either a tile or an object and can be identified using their marker component: <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/physics/collider/struct.TiledColliderMarker.html"><code>TiledColliderMarker</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layers-z-ordering"><a class="header" href="#layers-z-ordering">Layers Z-ordering</a></h1>
<p>When designing your map under Tiled, you expect that a layer will hide another one which is below in the layer hierarchy.
This is very useful when using isometric tiles for instance.</p>
<p>To reproduce this behaviour under Bevy, we add an arbitrary offset on the Z transform to each layers of the hierarchy.</p>
<p>If we call this offset <code>OFFSET</code>:</p>
<ul>
<li>the top-level layer will have a Z transform of <code>0</code></li>
<li>the second one will have a Z transform of <code>- OFFSET</code></li>
<li>the next one of <code>- 2*OFFSET</code></li>
<li>etc...</li>
</ul>
<p>By default this offset has a value of <code>+100</code>.
It can be changed by tweaking the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapSettings.html"><code>TiledMapSettings</code></a> component.
Since <code>bevy_ecs_tilemap</code> also play with the Z-transform to adjust how tiles from a given layers are rendered, you probably don't want to have a &quot;too low&quot; value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-loading-events"><a class="header" href="#map-loading-events">Map loading events</a></h1>
<p>After loading a map, the plugin will send several events:</p>
<ul>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/events/struct.TiledMapCreated.html"><code>TiledMapCreated</code></a>: called once the map has finished loading.</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/events/struct.TiledLayerCreated.html"><code>TiledLayerCreated</code></a>: called for all layers.</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/events/struct.TiledObjectCreated.html"><code>TiledObjectCreated</code></a>: called for all objects.</li>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/events/struct.TiledSpecialTileCreated.html"><code>TiledSpecialTileCreated</code></a>: only called for &quot;special tiles&quot; ie. tiles with either custom properties or colliders.</li>
</ul>
<p>These events are a way to access directly raw <code>Tiled</code> data and easily extend the plugin capabilities.</p>
<p>For instance, you can access a <code>tiled::Object</code> from the corresponding event:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn object_created(
    trigger: Trigger&lt;TiledObjectCreated&gt;,
    map_asset: Res&lt;Assets&lt;TiledMap&gt;&gt;,
) {
    // Access raw Tiled data
    let _map = trigger.event().map(&amp;map_asset);
    let _layer = trigger.event().layer(&amp;map_asset);
    let object = trigger.event().object(&amp;map_asset);
    info!(&quot;Loaded object: {:?}&quot;, object);
}
<span class="boring">}
</span></code></pre></pre>
<p>A <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/map_events.rs">dedicated example</a> is available to demonstrate how to use these.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimal-working-example"><a class="header" href="#minimal-working-example">Minimal working example</a></h1>
<p>Add dependencies to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
bevy = &quot;0.15&quot;
bevy_ecs_tiled = &quot;0.5&quot;
bevy_ecs_tilemap = &quot;0.15&quot;
</code></pre>
<p>Then add the plugin to your app and spawn a map:</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;
use bevy_ecs_tilemap::prelude::*;

fn main() {
    App::new()
        // Add Bevy default plugins
        .add_plugins(DefaultPlugins)
        // Add bevy_ecs_tilemap plugin
        .add_plugins(TilemapPlugin)
        // Add bevy_ecs_tiled plugin
        .add_plugins(TiledMapPlugin::default())
        // Add our startup function to the schedule and run the app
        .add_systems(Startup, startup)
        .run();
}

fn startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    // Spawn a 2D camera
    commands.spawn(Camera2d);

    // Load the map: ensure any tile / tileset paths are relative to assets/ folder
    let map_handle: Handle&lt;TiledMap&gt; = asset_server.load(&quot;map.tmx&quot;);

    // Spawn the map with default options
    commands.spawn(TiledMapHandle(map_handle));
}
</code></pre></pre>
<p>Basically, all you have to do is to spawn a <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/struct.TiledMapHandle.html"><code>TiledMapHandle</code></a> with the map asset you want to load (the <code>map.tmx</code> file).
Note that this map asset should be in your local <code>assets/</code> folder, as well as required dependencies (for instance, associated tilesets).</p>
<p>You can tweak how to load the map by adding various components on the map entity, notably:</p>
<ul>
<li><a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapSettings.html"><code>TiledMapSettings</code></a></li>
<li><a href="https://docs.rs/bevy_ecs_tilemap/latest/bevy_ecs_tilemap/map/struct.TilemapRenderSettings.html"><code>TilemapRenderSettings</code></a></li>
<li><a href="https://docs.rs/bevy/latest/bevy/transform/components/struct.Transform.html"><code>Transform</code></a></li>
<li><a href="https://docs.rs/bevy/latest/bevy/render/view/visibility/enum.Visibility.html"><code>Visibility</code></a></li>
</ul>
<p>You can browse the <a href="https://github.com/adrien-bon/bevy_ecs_tiled/tree/main/examples/README.md">examples</a> for more advanced use cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawn--despawn--reload-a-map"><a class="header" href="#spawn--despawn--reload-a-map">Spawn / Despawn / Reload a map</a></h1>
<p>These aspects are also covered in the <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/map_reload.rs">dedicated example</a>.</p>
<h2 id="spawn-a-map"><a class="header" href="#spawn-a-map">Spawn a map</a></h2>
<p>Spawning a map is done in two steps:</p>
<ul>
<li>first, load a map asset / a map file using the Bevy <code>AssetServer</code></li>
<li>then, spawn a <code>TiledMapHandle</code> containing a reference to this map asset</li>
</ul>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn spawn_map(
    mut commands: Commands,
    asset_server: Res&lt;AssetServer&gt;
) {
    // First, load the map
    let map_handle: Handle&lt;TiledMap&gt; = asset_server.load(&quot;map.tmx&quot;);

    // Then, spawn it, using default settings
    commands.spawn(TiledMapHandle(map_handle));
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that you can perform the initial map loading beforehand (for instance, during your game startup) and  that there is no restriction on the number of maps loaded or spawned at the same time.</p>
<h2 id="despawn-a-map"><a class="header" href="#despawn-a-map">Despawn a map</a></h2>
<p>If you want to despawn a map, the easiest is to actually remove its top-level entity:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn despawn_map(
    mut commands: Commands,
    maps_query: Query&lt;Entity, With&lt;TiledMapMarker&gt;&gt;,
) {
    // Iterate over entities with a TiledMapMarker component
    for map in q_maps.iter() {
        // Despawn these entities, as well as their child entities
        commands.entity(map).despawn_recursive();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>All child entities, like layers and tiles, will automatically be despawned.</p>
<h2 id="respawn--reload-a-map"><a class="header" href="#respawn--reload-a-map">Respawn / reload a map</a></h2>
<p>If you want to reload or respawn a map, you can of course despawn it then spawn it again.
It's tedious, but it works.</p>
<p>However, there is an easier way.
You can instead insert the <code>RespawnTiledMap</code> component to the map entity:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn respawn_map(
    mut commands: Commands,
    maps_query: Query&lt;Entity, With&lt;TiledMapMarker&gt;&gt;,
) {
    if let Ok(entity) =  maps_query.get_single() {
        commands.entity(entity).insert(RespawnTiledMap);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This will load the exact same map but using new entities for layers or tiles (map entity will be preserved).
It means that if you updated some components (for instance, a tile color or an object position) they will be back as they were when you first loaded the map.
It's useful to implement a level respawn for instance.</p>
<p>Another use case is to load a new map over an existing one.
An easy way to do that is to just spawn a new <code>TiledMapHandle</code> over an existing map.
Note you can also reload the exact same map, which is equivalent to using the <code>RespawnTiledMap</code> component.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_reload(
    mut commands: Commands,
    asset_server: Res&lt;AssetServer&gt;,
    maps_query: Query&lt;Entity, With&lt;TiledMapMarker&gt;&gt;,
) {
    if let Ok(entity) = maps_query.get_single() {
        commands.entity(entity)
            .insert(
                TiledMapHandle(asset_server.load(&quot;other_map.tmx&quot;))
            );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In both cases, note that map additional components such as <code>TiledMapSettings</code> or <code>TilemapRenderSettings</code> will be preserved.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-physics-colliders"><a class="header" href="#add-physics-colliders">Add physics colliders</a></h1>
<p>Tiled allows you to add objects to your map: either directly on an object layer or attached to a tile.
<code>bevy_ecs_tiled</code> can use these objects to automatically spawn physics colliders when loading the map.</p>
<p>We provide two working physics backend: one using <a href="https://github.com/Jondolf/avian"><code>avian</code></a> and another one using <a href="https://github.com/dimforge/bevy_rapier"><code>bevy_rapier</code></a>.
They are the same in terms of features regarding <code>bevy_ecs_tiled</code> so feel free to choose the one you prefer.</p>
<p>The API also allows you to provide a custom physics backend or to customize existing ones.</p>
<h2 id="create-objects-in-tiled"><a class="header" href="#create-objects-in-tiled">Create objects in Tiled</a></h2>
<p>First step is to have on your map something that we can actually use to spawn a collider: objects.</p>
<p>In Tiled, there are two kinds of objects:</p>
<ul>
<li>objects attached to an object layer: these are the regular objects you can place on the map when working on an object layer.</li>
<li>objects attached to a tile: for these, you will need to actually <a href="https://doc.mapeditor.org/en/stable/manual/editing-tilesets/#tile-collision-editor">edit your tileset</a>.</li>
</ul>
<p>These two kinds of objects, eventhough they are handled a bit differently, will actually produce the same result: using the object shape we will be able to spawn a collider.
So, as you can imagine, a &quot;Point&quot; object will not produce anything physics-wise :)</p>
<p>One important aspect is to remember that you change the name of your objects.</p>
<h2 id="automatically-spawn-colliders"><a class="header" href="#automatically-spawn-colliders">Automatically spawn colliders</a></h2>
<p>In order to automatically spawn colliders from Tiled objects, you need two things:</p>
<ul>
<li>having the proper feature enabled: you will either need <code>avian</code> or <code>rapier</code>, depending on your backend choice (you can eventually only enable <code>physics</code>, but you it means you will provide the backend yourself).</li>
<li>instanciate the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/physics/struct.TiledPhysicsPlugin.html"><code>TiledPhysicsPlugin</code></a> with an associated <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/physics/trait.TiledPhysicsBackend.html"><code>TiledPhysicsBackend</code></a>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

// This is a minimal example: in a real world scenario, you would probably
// need to load additionnal plugins (TiledMapPlugin and TilemapPlugin for instance)

fn main() {
    App::new()
        // bevy_ecs_tiled physics plugin: this is where we select
        // which physics backend to use (in this case, Avian)
        .add_plugins(TiledPhysicsPlugin::&lt;TiledPhysicsAvianBackend&gt;::default())
        // Add our systems and run the app!
        .add_systems(Startup, startup)
        .run();
}

// Just load the map as usual
fn startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    commands.spawn(Camera2d);
    commands.spawn(TiledMapHandle(asset_server.load(&quot;finite.tmx&quot;)));
}
</code></pre></pre>
<p>By default, we will spawn physics colliders for <strong>all</strong> objects encountered in the map.
Eventhough it's probably the most common behaviour, you can also fine tune for which objects you want to spawn colliders for by updating the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/physics/struct.TiledPhysicsSettings.html"><code>TiledPhysicsSettings</code></a> component.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

// Load the map with custom physics settings (and an Avian backend)
fn startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    commands.spawn(Camera2d);
    commands.spawn((
        TiledMapHandle(asset_server.load(&quot;finite.tmx&quot;)),
        // With this configuration, we will restrict the spawn of collider
        // for objects named 'collision' attached to a tile.
        // No collider for objects attached to objects layer.
        TiledPhysicsSettings::&lt;TiledPhysicsAvianBackend&gt; {
            objects_layer_filter: ObjectNames::None,
            tiles_objects_filter: ObjectNames::Names(vec![&quot;collision&quot;.to_string()]),
            ..default()
        },
    ));
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="custom-physics-backend-and-colliders-event"><a class="header" href="#custom-physics-backend-and-colliders-event">Custom physics backend and colliders event</a></h2>
<p>If you need to, the API will let you to add your own physics behaviour.</p>
<p>You can eventually define your own physics backend.
All you need to do is to create a struct that implements the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/physics/trait.TiledPhysicsBackend.html"><code>TiledPhysicsBackend</code></a> trait, ie. provide an implementation for the <code>spawn_collider</code> function.</p>
<p>You can even use one the provided backend, but if their implementation have something missing for you, you can wrap your own implementation around and existing backend (see <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/physics_avian_controller.rs">this example for Avian</a> or <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/physics_rapier$_controller.rs">this one for Rapier</a>).</p>
<p>Finally, whatever the backend you are using, a dedicated <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/physics/collider/struct.TiledColliderCreated.html"><code>TiledColliderCreated</code></a> event will be fired after a collider is spawned.
Note that you will have one event per spawned collider.
These events can be used for instance to add a missing component to the collider (or anything you want).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-tiled-custom-properties"><a class="header" href="#use-tiled-custom-properties">Use Tiled custom properties</a></h1>
<p>In Tiled we can add &quot;custom properties&quot; on various items like layers, tiles, objects or maps.</p>
<p>These custom properties can be either:</p>
<ul>
<li>a &quot;standard type&quot;, like a string, an integer, a float, a color, etc...</li>
<li>a &quot;custom type&quot;, which is basically a structure with sub-properties that can either be a &quot;standard type&quot; or another &quot;custom type&quot;</li>
</ul>
<p>In <code>bevy_ecs_tiled</code> we support mapping a Tiled &quot;custom type&quot; to a Bevy <code>Component</code>, <code>Bundle</code> or even <code>Resource</code>.
Basically, it means that we can define some game logic directly in the Tiled map to use it in your game with Bevy.</p>
<p>Using this mechanism, we could for instance:</p>
<ul>
<li>associate a &quot;movement cost&quot; to a given tile type</li>
<li>create an object that represent our player or an ennemy</li>
<li>add a generic &quot;trigger zone&quot; that could either be a &quot;damaging zone&quot; or a &quot;victory zone&quot;</li>
<li>... whatever you need for your game!</li>
</ul>
<p>In addition to this guide, there is also a <a href="https://github.com/adrien-bon/bevy_ecs_tiled/blob/main/examples/properties_basic.rs">dedicated example</a>.</p>
<h2 id="declare-types-to-be-used-as-custom-properties"><a class="header" href="#declare-types-to-be-used-as-custom-properties">Declare types to be used as custom properties</a></h2>
<p>Your Tiled map, layer, tile or object will be represented by a Bevy <code>Entity</code>.
So, it makes sense that if you want to add custom properties to them, these properties should either be a <code>Component</code> or a <code>Bundle</code>.</p>
<p>Tiled custom properties use Bevy <code>Reflect</code> mechanism.
In order to be usable in Tiled, your custom types must be &quot;Reflectable&quot;.
To do, these types must derive the <code>Reflect</code> trait and get registered with Bevy.</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;

// Declare a component that is &quot;reflectable&quot;
#[derive(Component, Reflect, Default)]
#[reflect(Component, Default)]
struct SpawnInfos {
    has_spawned: bool,
    ty: SpawnType,
}

// Any 'sub-type' which is part of our component must also be &quot;reflectable&quot;
#[derive(Default, Reflect)]
#[reflect(Default)]
enum SpawnType {
    #[default]
    Unknown,
    Player,
    Enemy,
}

// Register our type with Bevy
fn main() {
    App::new()
        .register_type::&lt;SpawnInfos&gt;();
}
</code></pre></pre>
<p>And that's all for the code part !</p>
<p>Note that in the above example, our custom type also derive the <code>Default</code> trait.
It is particulary useful to do so: if you don't, you would have to fill all the fields of your custom type when you use it in Tiled.</p>
<p>Finally, note that you can also add <code>Resource</code> to your map.
Since <code>Resource</code>s are not attached to a particular entity and they are shared accros your app, we chose to restrict their usage only as Tiled map properties.</p>
<h2 id="add-custom-properties-to-your-map"><a class="header" href="#add-custom-properties-to-your-map">Add custom properties to your map</a></h2>
<p>Before you can add custom properties to your map, you will need to export them from Bevy then import them in Tiled.</p>
<p>When running with the <code>user_properties</code> feature, your app will automatically produce an export of all types registered with Bevy.
By default, this file will be produced in your workspace with the name <code>tiled_types_export.json</code>.
You can change this file name or even disable its production by tweaking the <code>TiledMapPlugin</code> configuration (see <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/struct.TiledMapPluginConfig.html"><code>TiledMapPluginConfig</code></a>).</p>
<p>You can then import this file to Tiled.
To do so, in Tiled, navigate to View -&gt; Custom Types Editor:</p>
<p><img src="guides/images/properties_view-types.png" alt="view-custom-types" /></p>
<p>Click on the <code>Import</code> button and load your file:</p>
<p><img src="guides/images/properties_import-types.png" alt="import-custom-types" /></p>
<p>Once it is done, you will be able to see all the custom types that you have imported from your application.
Note that it concerns all the types that derive the <code>Reflect</code> trait: there can be quite a lot !</p>
<p><img src="guides/images/properties_custom-type.png" alt="view-custom-types" /></p>
<p>You can now add them to different elements of your map, like tiles objects, layers or the map itself.
For more information on how to do add custom properties, see the <a href="https://doc.mapeditor.org/en/stable/manual/custom-properties/">official Tiled documentation</a>.</p>
<p>You should only add properties imported from Bevy: adding ones that you created only in Tiled will not be loaded in Bevy if they do not contain actual Bevy <code>Component</code>s.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-your-project"><a class="header" href="#debug-your-project">Debug your project</a></h1>
<h2 id="bevy-inspector-egui"><a class="header" href="#bevy-inspector-egui"><code>bevy-inspector-egui</code></a></h2>
<p>This may be obvious but this plugin is a must have for debugging.</p>
<p>Just add the required dependency in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
bevy-inspector-egui = &quot;0.25.2&quot;
</code></pre>
<p>Then add the <code>WorldInspectorPlugin</code> to your application:</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_inspector_egui::quick::WorldInspectorPlugin;

fn main() {
    App::new()
        .add_plugins(WorldInspectorPlugin::new())
        .run();
}
</code></pre></pre>
<p>Now, you can browse components from all entities spawned in your game.</p>
<p>More informations on the project <a href="https://github.com/jakobhellermann/bevy-inspector-egui">github page</a>.</p>
<h2 id="tiledmapdebugplugin"><a class="header" href="#tiledmapdebugplugin"><code>TiledMapDebugPlugin</code></a></h2>
<p><code>bevy_ecs_tiled</code> provides a debug plugin that displays a gizmos where Tiled object are spawned.</p>
<p>To use it, you just have to enable the <code>debug</code> feature and add the plugin to your application:</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn main() {
    App::new()
        .add_plugins(TiledMapDebugPlugin::default())
        .run();
}
</code></pre></pre>
<p>More informations in the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/debug/index.html">API reference</a>.</p>
<h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<p>Both Avian and Rapier provide their own way of debugging.
It can be very useful, especially when working with colliders.
Note that physics debugging is enabled by default in all <code>bevy_ecs_tiled</code> examples using physics.</p>
<p>To enable physics debugging in Avian, you need to simply add the corresponding plugin:</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use avian2d::prelude::*;

fn main() {
    App::new()
        // Add Avian regular plugin
        .add_plugins(PhysicsPlugins::default().with_length_unit(100.0))
        // Add Avian debug plugin
        .add_plugins(PhysicsDebugPlugin::default())
        .run();
}
</code></pre></pre>
<p>For Rapier, you need to enable a debug plugin:</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_rapier2d::prelude::*;

fn main() {
    App::new()
        // Add Rapier regular plugin
        .add_plugins(RapierPhysicsPlugin::&lt;NoUserData&gt;::pixels_per_meter(100.0))
        // Add Rapier debug plugin
        .add_plugins(RapierDebugRenderPlugin::default())
        .run();
}
</code></pre></pre>
<p>And you also need to enable either the <code>debug-render-2d</code> feature on <code>bevy_rapier2d</code> crate or the <code>rapier_debug</code> feature on <code>bevy_ecs_tiled</code></p>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>Bevy uses the <code>tracing</code> crate for logging, which is very powerful in debugging and profiling, you can find more information in the <a href="https://docs.rs/tracing/">official documentation</a>.</p>
<p>We recommend to enable the <code>trace</code> level in your application to get more informations about what's happening, just set the <code>RUST_LOG</code> environment variable to <code>trace</code>:</p>
<pre><code class="language-sh">RUST_LOG=trace cargo run
</code></pre>
<p>But this will be very verbose, so you can also filter the logs to only display the informations you need:</p>
<pre><code class="language-sh">RUST_LOG=bevy_ecs_tiled=trace cargo run
</code></pre>
<p>This will only display logs from the <code>bevy_ecs_tiled</code> crate in <code>trace</code> level.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-v04x-to-v05x"><a class="header" href="#from-v04x-to-v05x">From v0.4.X to v0.5.X</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Version 0.5 updates the crate for Bevy v0.15.
It notably takes advantage of the new <code>required_component</code> feature to simplify the crate API.</p>
<p>Also, this version provide some fixes related to user properties.
If you are using them, you should reload your export file.</p>
<h2 id="bevy-v015-update"><a class="header" href="#bevy-v015-update">Bevy v0.15 update</a></h2>
<p><a href="https://bevyengine.org/learn/migration-guides/0-14-to-0-15/">Bevy official migration guide</a></p>
<h2 id="misc-changes"><a class="header" href="#misc-changes">Misc changes</a></h2>
<h3 id="tiledmapsettings-update"><a class="header" href="#tiledmapsettings-update"><code>TiledMapSettings</code> update</a></h3>
<p><code>map_initial_transform</code> and <code>map_initial_visibility</code> have been removed from <code>TiledMapSettings</code>.</p>
<p>If you want to tweak your map positioning or visibility, you should instead directly insert corresponding <code>Transform</code> or <code>Visibility</code> components on the map entity.</p>
<p>Before:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let map_handle: Handle&lt;TiledMap&gt; = asset_server.load(&quot;map.tmx&quot;);
    commands.spawn((
        TiledMapHandle(map_handle),
        TiledMapSettings {
            map_initial_transform: Transform::from_xyz(150., 100., 0.),
            map_initial_visibility: Visibility::Hidden,
            ..Default::default()
        },
    ));
<span class="boring">}
</span></code></pre></pre>
<p>After:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let map_handle: Handle&lt;TiledMap&gt; = asset_server.load(&quot;map.tmx&quot;);
    commands.spawn((
        TiledMapHandle(map_handle),
        Transform::from_xyz(150., 100., 0.),
        Visibility::Hidden,
    ));
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-v03x-to-v04x"><a class="header" href="#from-v03x-to-v04x">From v0.3.X to v0.4.X</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Version 0.4 was initially motivated by an update to the way we handle user properties but ended as a major overhaul of the plugin to provide a better API and to give more control to the user.</p>
<h2 id="plugin-instanciation"><a class="header" href="#plugin-instanciation">Plugin instanciation</a></h2>
<p>The plugin now has an associated configuration, which you need to provide when you add it to your application.</p>
<p>The easiest way is to use the default configuration value :</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn main() {
    App::new()
        // You still need the bevy_ecs_tilemap plugin
        .add_plugins(TilemapPlugin)
        // And now, you have to provide a configuration for bevy_ecs_tiled plugin
        .add_plugins(TiledMapPlugin::default())
        .run();
}
</code></pre></pre>
<p>The plugin configuration is described in the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/struct.TiledMapPluginConfig.html">API reference</a></p>
<h2 id="tiled-map-spawn-and-configuration"><a class="header" href="#tiled-map-spawn-and-configuration">Tiled map spawn and configuration</a></h2>
<p>The plugin entry point, ie. the <code>TiledMapBundle</code> bundle is gone.
It was cumbersome and did not allow for a proper separation of concerns (for instance, for physics).</p>
<p>Also, the <code>Handle&lt;TiledMap&gt;</code> type is not a Bevy component anymore.
It was done in order to anticipate expected changes in Bevy where <code>Handle&lt;T&gt;</code> won't be able to derive the <code>Component</code> trait anymore.</p>
<p>Anyway, the new way to spawn a map is now easier: you just have to spawn a <code>TiledMapHandle</code> referencing your .TMX file asset:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::prelude::*;
use bevy_ecs_tiled::prelude::*;

fn startup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    // Load the map: ensure any tile / tileset paths are relative to assets/ folder
    let map_handle: Handle&lt;TiledMap&gt; = asset_server.load(&quot;map.tmx&quot;);

    // Spawn the map with default options
    commands.spawn(TiledMapHandle(map_handle));
}
<span class="boring">}
</span></code></pre></pre>
<p>You can customize various settings about how to load the map by inserting the <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/struct.TiledMapSettings.html"><code>TiledMapSettings</code></a> component on the map entity.</p>
<h2 id="tiled-user-properties"><a class="header" href="#tiled-user-properties">Tiled user properties</a></h2>
<p>Before this change, you had to define your custom types both in Tiled and in your rust code.
It was not user-friendly and error-prone.</p>
<p>Now, we take advantage of <code>bevy_reflect</code> to generate a file containing all the types known to Bevy.
This file can be imported in Tiled so you can use these types directly in the editor.</p>
<p>Migrating from the old implementation should be straight-forward.</p>
<p>First, you need need to update your custom types so they actually implement the <code>Reflect</code> trait :</p>
<ul>
<li>remove <code>#[derive(TiledObject)]</code>, <code>#[derive(TiledCustomTile)]</code>, <code>#[derive(TiledClass)]</code> and <code>#[derive(TiledEnum)]</code> derived traits. Make sure to also remove associated attributes.</li>
<li>add <code>#[derive(Reflect)]</code> derive trait on the types you want to use in Tiled.</li>
<li>make sure your components have the <code>#[reflect(Component)]</code> attribute</li>
</ul>
<p>Then, in your main / in your plugin setup, you then need to register your types with Bevy :</p>
<ul>
<li>replace calls to <code>register_tiled_object::&lt;T&gt;()</code> with calls to <code>register_type::&lt;T&gt;()</code>.</li>
<li>replace calls to <code>register_tiled_custom_tile::&lt;T&gt;()</code> with calls to <code>register_type::&lt;T&gt;()</code>.</li>
</ul>
<p>The final step is to actually generate the types import file (run your game once) and import the types to Tiled.
Note that you may have to update your map / your tilesets to use the new types you just imported.</p>
<p><a href="migrations/../guides/properties.html"><strong>A dedicated guide about how to setup user properties is available in this book</strong></a>.</p>
<h2 id="tiled-physics"><a class="header" href="#tiled-physics">Tiled physics</a></h2>
<p>Eventhough functionnalities around physics did not change much, the internals have been completely reworked and the API was updated a bit.</p>
<p>Notably, now you need to instanciate another plugin and specify which physics backend you want to use.
<a href="migrations/../guides/physics.html">The physics section of the book should get you through</a>.</p>
<h2 id="map-events"><a class="header" href="#map-events">Map events</a></h2>
<p>This is a new feature of this version which gives more control to the user over what he wants to do with a Tiled map.
<a href="migrations/../design/map_events.html">More information in the dedicated section</a></p>
<h2 id="misc-changes-1"><a class="header" href="#misc-changes-1">Misc changes</a></h2>
<h3 id="enum-mappositioning"><a class="header" href="#enum-mappositioning"><code>enum MapPositioning</code></a></h3>
<p>Both enum name and fields name have been updated to better reflect what they actually do.
You should now use the new <a href="https://docs.rs/bevy_ecs_tiled/latest/bevy_ecs_tiled/components/enum.LayerPositioning.html"><code>LayerPositioning</code></a> enum.</p>
<h3 id="fn-from_isometric_coords_to_bevy"><a class="header" href="#fn-from_isometric_coords_to_bevy"><code>fn from_isometric_coords_to_bevy()</code></a></h3>
<p>Parameters <code>tiled_position: Vec2</code> and <code>iso_coords: IsoCoordSystem</code> have been swapped for better consistency with other utility functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-links"><a class="header" href="#useful-links">Useful links</a></h1>
<p>Here is an unordered list of useful resources that may help when working on a 2D tile-base game.</p>
<p>Feel free to suggest any other link!</p>
<h2 id="notable-crates"><a class="header" href="#notable-crates">Notable crates</a></h2>
<ul>
<li><a href="https://github.com/bevyengine/bevy"><code>bevy</code></a>: the Bevy engine</li>
<li><a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code></a>: the crate we use for rendering our tiles</li>
<li><a href="https://github.com/mapeditor/rs-tiled"><code>rs-tiled</code></a>: official Tiled rust bindings</li>
<li><a href="https://github.com/Trouv/bevy_ecs_ldtk"><code>bevy_ecs_ldtk</code></a>: an equivalent of <code>bevy_ecs_tiled</code> but for the <a href="https://ldtk.io/">LDTK</a> map editor</li>
<li><a href="https://github.com/ManevilleF/hexx"><code>hexx</code></a>: an hexagonal tools lib for stuff like path-finding or hex coordinates manipulation</li>
<li><a href="https://github.com/aevyrie/bevy_mod_picking/"><code>bevy_mod_picking</code></a>: a flexible set of plugins that add picking functionality to your bevy app</li>
<li><a href="https://github.com/zacryol/bevy_picking_tilemap"><code>bevy_picking_tilemap</code></a>: provides a <a href="https://github.com/aevyrie/bevy_mod_picking/"><code>bevy_mod_picking</code></a> backend to add integration with <a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code></a>, enabling individual Tile entities to receive the picking events</li>
<li><a href="https://github.com/Jondolf/avian"><code>avian</code></a>: Avian physic backend</li>
<li><a href="https://github.com/dimforge/bevy_rapier"><code>bevy_rapier</code></a>: Rapier physic backend</li>
</ul>
<h2 id="notable-resources"><a class="header" href="#notable-resources">Notable resources</a></h2>
<ul>
<li><a href="https://bevyengine.org/">Bevy official website</a>: lots of examples and learning materials</li>
<li><a href="https://docs.rs/bevy/latest/bevy/">Bevy API reference</a></li>
<li><a href="https://bevy-cheatbook.github.io/">Unofficial Bevy Cheat Book</a>: one the best resource to learn Bevy</li>
<li><a href="https://www.mapeditor.org/">Tiled official website</a>: to get the latest Tiled version and read associated documentation</li>
<li><a href="https://www.redblobgames.com/">Red Blob Games</a>: collections of tutorials on various gamedev topics, especially the <a href="https://www.redblobgames.com/grids/hexagons/">hexagonal grids reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>If you would like to contribute but you're unsure where to start, here is a short wishlist and some notes on how to get started.</p>
<p>First, you can have a look at <a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues">GH issues</a>.
More specifically, the ones that are:</p>
<ul>
<li><a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues?q=is%3Aopen+is%3Aissue+label%3Aenhancement">tagged with <code>enhancement</code> label</a></li>
<li><a href="https://github.com/adrien-bon/bevy_ecs_tiled/issues?q=is%3Aopen+is%3Aissue+label%3Alimitation">tagged with <code>limitation</code> label</a></li>
</ul>
<p>If you feel like you can tackle on of these, please, feel free to submit a PR!</p>
<p>Helping other users, respond to issues, help review PRs or just openning new issues is also very helpful !</p>
<p>Also, another way of helping is to contribute on crates we rely on, namely <a href="https://github.com/mapeditor/rs-tiled"><code>rs-tiled</code></a> and <a href="https://github.com/StarArawn/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code></a>, or anything else in the Bevy ecosystem.</p>
<h2 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution guidelines</a></h2>
<p>If you submit a PR, please make sure that:</p>
<ul>
<li>the CI is green: you can locally run the <code>./ci_check.sh</code> script</li>
<li>you add proper in-code documentation</li>
<li>you update the <code>CHANGELOG.md</code> file with a description of your fix</li>
<li>if you add a new example, update the <code>examples/README.md</code> file with a description of your example and the <code>Cargo.toml</code> file with your example name (and any feature it may need)</li>
<li>if you add a new map, update the <code>assets/README.md</code> file with your map characteristics</li>
<li>if you add a new asset, update the &quot;Assets credits&quot; section of the <code>README.md</code> file and make sure that you actually have the right to use it!</li>
</ul>
<p>Thanks in advance! :)</p>
<div style="break-before: page; page-break-before: always;"></div><meta http-equiv="Refresh" content="0; url='https://docs.rs/bevy_ecs_tiled/'" />
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
